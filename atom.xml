<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>PleaseCallMeCoder</title>
  <subtitle>每个人都在成神的路上，只不过有的人在走，而有的人在跑。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-11-10T03:05:17.270Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>任磊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>不只是迭代器模式</title>
    <link href="http://yoursite.com/2016/11/03/%E4%B8%8D%E5%8F%AA%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/11/03/不只是迭代器模式/</id>
    <published>2016-11-03T03:41:00.000Z</published>
    <updated>2016-11-10T03:05:17.270Z</updated>
    
    <content type="html">&lt;p&gt; 不只是迭代器模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#写在前面的话&lt;/p&gt;
&lt;p&gt;这章为什么叫不只是迭代器模式呢？首先声明我不是标题党，不是为了引起注意。&lt;strong&gt;古人说认知东西的三种境界，看山是山，看山不是山，看山还是山&lt;/strong&gt;，认知总是要有一个过程才行。而最近在我研究设计模式的过程中就有一种学进去没跳出来的感觉，用和尚的话来说就是&lt;strong&gt;着相了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;##学进去和跳出来&lt;/p&gt;
&lt;p&gt;最近写了几篇有关Android源码和设计模式的博客，然后发现最近的思考方式有点过于注意细枝末节了。而我认识一个东西的习惯是&lt;strong&gt;在关注细节的同时也必须要对这个东西在宏观上有一个认知&lt;/strong&gt;。&lt;strong&gt;既要能学进去，又要能跳出来&lt;/strong&gt;。所以我们不妨先跳出来，复习一下设计模式的概况。&lt;/p&gt;
&lt;p&gt;##什么是设计模式&lt;/p&gt;
&lt;p&gt;在软件工程中，设计模式（design pattern）是对软件设计中普遍存在的各种问题，所提出的解决方案。&lt;strong&gt;设计模式并不是固定的一套代码，而是针对某一特定问题的具体解决思路与方案&lt;/strong&gt;。可以认为是&lt;strong&gt;一种最佳实践&lt;/strong&gt;，因为他是无数软件开发人员经过长时间的实践总结出来的。&lt;/p&gt;
&lt;p&gt;##为什么要学习设计模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;复用解决方案&lt;/strong&gt;：模式是对一个通用设计问题可以复用的解决方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;确立通用术语&lt;/strong&gt;：模式在开发者沟通之间提供了一机制,允许开发者在更高的层次沟通而不是代码层面，并且目标是理解被开发的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;设计模式的具体作用：减少各个分析类之间的耦合和依赖&lt;/strong&gt;。使软件更容易修改和维护，更善于&lt;strong&gt;应对变化&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实在我们每看一个设计模式的时候要记得无论它是哪种模式，它的初衷都是一样的。&lt;strong&gt;我们不一定要用这些设计模式，也不一定要生搬硬套这些设计，我们要做的是解决问题，只不过这些模式在解决这些问题上更成熟，所以才被大家广泛使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们没有遇到设计模式的使用场景，或者之后的变化也不会用到，就不要去思考如何用设计模式优化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来开始今天的正题，看下我们的迭代器模式。&lt;/p&gt;
&lt;p&gt;#定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;提供一种方法访问一个容器对象中各个元素，而又不需要暴露对象的内部细节。是一种行为型设计模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#使用场景&lt;/p&gt;
&lt;p&gt;迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。&lt;/p&gt;
&lt;p&gt;但是，由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。&lt;/p&gt;
&lt;p&gt;#结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/l9AkaDE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;模式所涉及的角色有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;迭代器角色(Iterator)&lt;/strong&gt;：迭代器角色负责定义访问和遍历元素的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;具体迭代器角色(ConcreteIterator)&lt;/strong&gt;：具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;容器角色(Aggregate)&lt;/strong&gt;：容器角色负责提供创建具体迭代器角色的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;具体容器角色(ConcreteAggregate)&lt;/strong&gt;：具体容器角色实现创建具体迭代器角色的接口。这个具体迭代器角色与该容器的结构相关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#实现&lt;/p&gt;
&lt;p&gt;这里我们用一个现实中的例子来演示一下迭代器模式。场景是这样的：我们要创办一个提供家具一站式服务的公司，但是我们并不自己生产家具，我们有自己获取家具的渠道。可是每个渠道存储他们产品的数据结构可能是不一样的，我们怎样才能方便的访问他们的产品呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不知道大家发现没，大部分设计模式解耦或者封装变化的方式都是加了一个中间层&lt;/strong&gt;。迭代器模式也是这样的，&lt;strong&gt;Iterator就是一个中间层，封装了各个数据结构遍历的变化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;迭代器角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Iterator&amp;lt;T&amp;gt; {

    T next();

    boolean hasNext();

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体电视厂商的迭代器角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TVIterator implements Iterator&amp;lt;TVBean&amp;gt; {

    private List&amp;lt;TVBean&amp;gt; list = new ArrayList&amp;lt;TVBean&amp;gt;();
    private int cursor = 0;

    public TVIterator(TVCompany tvCompany) {
        list = tvCompany.getTvList();
    }

    @Override
    public TVBean next() {
        TVBean tv = null;
        if (this.hasNext()) {
            tv = this.list.get(cursor++);
        }
        return tv;
    }

    @Override
    public boolean hasNext() {
        if (cursor == list.size()) {
            return false;
        }
        return true;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;容器角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Aggregate&amp;lt;T&amp;gt; {

    void add(T t);

    void remove(T t);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体电视容器类角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class TVCompany implements Aggregate&amp;lt;TVBean&amp;gt; {

    private List&amp;lt;TVBean&amp;gt; tvList;

    public TVCompany() {
        tvList = new ArrayList&amp;lt;&amp;gt;();
    }

    public List&amp;lt;TVBean&amp;gt; getTvList() {
        return tvList;
    }

    @Override
    public void add(TVBean tvBean) {
        tvList.add(tvBean);
    }

    @Override
    public void remove(TVBean tvBean) {
        tvList.remove(tvBean);
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试方法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private void testIterator() {
    TVCompany tvCompany = new TVCompany();
    tvCompany.add(new TVBean(0, &amp;quot;15寸&amp;quot;));
    tvCompany.add(new TVBean(1, &amp;quot;16寸&amp;quot;));
    tvCompany.add(new TVBean(2, &amp;quot;21寸&amp;quot;));
    tvCompany.add(new TVBean(3, &amp;quot;25寸&amp;quot;));
    tvCompany.add(new TVBean(4, &amp;quot;30寸&amp;quot;));
    TVIterator tvIterator = new TVIterator(tvCompany);
    while (tvIterator.hasNext()) {
        Log.e(&amp;quot;testIterator&amp;quot;, tvIterator.next().getName());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;依次类推，我们的空调厂商提供空调、冰箱厂商提供冰箱都是一样的道理。但是对于我们这个公司来说，&lt;strong&gt;我们需要关心的只有是否有下一个hasNext()和取出下一个next()&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;#Android源码中的迭代器模式&lt;/p&gt;
&lt;p&gt;就像在使用场景中说的那样，一般我们不会去自己实现一个迭代器，Android中用到迭代器的场景比较典型的场景是&lt;strong&gt;类集框架的遍历和数据库的Cursor&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在前面的&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52700648&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android中的工厂方法模式&lt;/a&gt;中，我们说Java的类集框架用到了工厂模式，现在我们再来看一下它的设计结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Dqcwfau.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们知道Iterator是迭代器，用来遍历一个集合中的元素。而不同的数据结构遍历的方式是不一样的，所以迭代器的实现也是不同的。每一个集合内部都会有一个Iterator的实现。使用工厂方法模式将迭代器的具体类型延迟到具体容器类中，比较灵活，容易扩展。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个模式比较简单，我们就不做过多说明了。搞定，收工。&lt;/p&gt;
&lt;p&gt;测试代码已上传到&lt;a href=&quot;https://github.com/PleaseCallMeCoder/DesignPatterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; 不只是迭代器模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Android源码与设计模式" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android源码" scheme="http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
      <category term="迭代器模式" scheme="http://yoursite.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android源码中的模板方法模式</title>
    <link href="http://yoursite.com/2016/10/19/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/10/19/Android源码中的模板方法模式/</id>
    <published>2016-10-19T09:54:00.000Z</published>
    <updated>2016-11-10T03:00:50.075Z</updated>
    
    <content type="html">&lt;p&gt; Android源码中的模板方法模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52624483&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;从装饰者模式到Context类族&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52640111&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;当观察者模式和回调机制遇上Android源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52672059&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码中的静态工厂方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52700648&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android中的工厂方法模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52755908&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码中的命令模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52807179&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码中的适配器模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52816893&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Android源码中的外观模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#使用场景&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/4P3YxUE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;模式所涉及的角色有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;抽象类（AbstractClass）&lt;/strong&gt;：实现了模板方法，定义了算法的骨架。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;具体类（ConcreteClass)&lt;/strong&gt;：实现抽象类中的抽象方法，已完成完整的算法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;模板方法中的方法可以分为两大类：模板方法和基本方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;模板方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。&lt;/p&gt;
&lt;p&gt;  一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;基本方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;抽象方法&lt;/strong&gt;：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;具体方法&lt;/strong&gt;：一个具体方法由抽象类声明并实现，而子类并不实现或置换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;钩子方法&lt;/strong&gt;：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#实现&lt;/p&gt;
&lt;p&gt;分析完理论，我们用一个饮料店出售饮料的小例子来分析一下模板方法模式。夏天我们去饮料店购买饮料，告诉服务员要&lt;strong&gt;一大杯奶茶，还要加冰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;那么饮料店是如何装配我们的饮料的呢？首先准备一个大杯子，然后入我们需要的饮料，如果加冰会放入一些冰块，最后盖好盖子打包给我们。&lt;/p&gt;
&lt;p&gt;仔细思考一下我们的使用场景，有没有发现很符合呢？接下来我们用代码实现一下。&lt;/p&gt;
&lt;p&gt;抽象方法，装配饮料的模板&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 饮料模板
 * Created by lei on 2016/10/19.
 */

public abstract class TemplateDrink {

    /**
     * 获取饮料的方法，用final修饰，防止被子类修改算法结构。模板方法
     */
    public final void getDrink() {
        getGlass();
        getContent();
        if (hook()) {
            Log.e(TAG, &amp;quot;加冰---&amp;gt;&amp;quot;);
        } else {
            Log.e(TAG, &amp;quot;不加冰---&amp;gt;&amp;quot;);
        }
        pack();
    }

    /**
     * 获取杯子，杯子分大中小杯
     */
    public abstract void getGlass();

    /**
     * 获取具体种类饮料
     */
    public abstract void getContent();

    /**
     * 夏天我们的饮料是默认加冰的。钩子方法
     */
    public boolean hook() {
        return true;
    }

    /**
     * 打包
     */
    public void pack() {
        Log.e(TAG, &amp;quot;包装&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;这里需要注意的是getDrink（）方法是用final修饰的，这样就保证了逻辑流程不会被子类修改，子类只能修改某一个步骤的具体实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体某种饮料的实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 具体的饮料，比如奶茶
 * Created by lei on 2016/10/19.
 */

public class ConcreteDrink extends TemplateDrink {

    @Override
    public void getGlass() {
        Log.e(TAG, &amp;quot;中杯---&amp;gt;&amp;quot;);
    }

    @Override
    public void getContent() {
        Log.e(TAG, &amp;quot;奶茶---&amp;gt;&amp;quot;);
    }

    @Override
    public boolean hook() {
        return super.hook();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#Android源码中的模板方法模式&lt;/p&gt;
&lt;p&gt;这个模式相对来说比较简单，但是应用却非常广泛，毕竟越简单越容易应用嘛。&lt;strong&gt;比如在重构的时候，把相同的代码抽取到父类中，然后配合钩子函数约束其行为。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然在Android源码中的应用肯定也不少，&lt;strong&gt;比如AsyncTask的实现，调用execute后会依次执行onPreExecute、doInBackground、onPostExecute,还可以通过onProgressUpdate来更新进度，它的执行过程其实是一个框架，类似的还有Activity的生命周期回调方法的执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们看一个比较明显的，即&lt;strong&gt;View中的Draw()方法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们先看下方法注释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* Manually render this view (and all of its children) to the given Canvas.
* The view must have already done a full layout before this function is
* called.  When implementing a view, implement
* {@link #onDraw(android.graphics.Canvas)} instead of overriding this method.
* If you do need to override this method, call the superclass version.
*
* @param canvas The Canvas to which the View is rendered.
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;即&lt;strong&gt;在我们调用layout()方法之后，可以调用draw()方法来手动渲染view(包括它的子view)到传入的canvas上。如果我们继承View类的话需要重写ondraw()方法而不是draw()。如果你必须重写，需要调用超类的版本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;draw()方法比较长，我们挑主要的看一下。&lt;/p&gt;
&lt;p&gt;方法开头有一段注释是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/*&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* Draw traversal performs several drawing steps which must be executed
* in the appropriate order:
*
*      1. Draw the background
*      2. If necessary, save the canvas&amp;apos; layers to prepare for fading
*      3. Draw view&amp;apos;s content
*      4. Draw children
*      5. If necessary, draw the fading edges and restore layers
*      6. Draw decorations (scrollbars for instance)
*/
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;遍历执行几个绘制步骤，并且这些步骤需要按适当顺序执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们重点看下3和4&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Step 3, draw the content
if (!dirtyOpaque) onDraw(canvas);

// Step 4, draw the children
dispatchDraw(canvas);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体方法如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Implement this to do your drawing.
 *
 * @param canvas the canvas on which the background will be drawn
 */
protected void onDraw(Canvas canvas) {
}

/**
 * Called by draw to draw the child views. This may be overridden
 * by derived classes to gain control just before its children are drawn
 * (but after its own view has been drawn).
 * @param canvas the canvas on which to draw the view
 */
protected void dispatchDraw(Canvas canvas) {

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看一下View类族的UML图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20161019174419222&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子类只能通过扩展onDraw(Canvas canvas)和dispatchDraw(Canvas canvas)两个函数，使子类的显示效果和别的具体子类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来对号入座，&lt;strong&gt;draw()对应我们的模板方法，ondraw()和dispatchDraw()就是钩子方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;搞定，收工。&lt;/p&gt;
&lt;p&gt;测试代码已上传到&lt;a href=&quot;https://github.com/PleaseCallMeCoder/DesignPatterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; Android源码中的模板方法模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Android源码与设计模式" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android源码" scheme="http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
      <category term="模板方法模式" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android源码中的外观模式</title>
    <link href="http://yoursite.com/2016/10/14/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/10/14/Android源码中的外观模式/</id>
    <published>2016-10-14T08:21:00.000Z</published>
    <updated>2016-11-10T03:02:45.865Z</updated>
    
    <content type="html">&lt;p&gt; Android源码中的外观模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52624483&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;从装饰者模式到Context类族&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52640111&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;当观察者模式和回调机制遇上Android源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52672059&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码中的静态工厂方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52700648&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android中的工厂方法模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52755908&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码中的命令模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52807179&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; Android源码中的适配器模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#定义&lt;/p&gt;
&lt;p&gt;外观模式(Facade Pattern)：&lt;strong&gt;外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#使用场景&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当你要为一个复杂子系统提供一个简单接口时。&lt;/li&gt;
&lt;li&gt;客户程序与抽象类的实现部分之间存在着很大的依赖性。引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。&lt;/li&gt;
&lt;li&gt;当你需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点，如果子系统之间是相互依赖的，你可以让他们仅通过Facade进行通讯，从而简化了他们之间的依赖关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/RxIXGLJ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;模式所涉及的角色有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Client : 客户端程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Facade : 对外的统一入口,即外观对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SubSystem : 子系统或者子服务等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#实现&lt;/p&gt;
&lt;p&gt;编程嘛，抽象于生活高于生活，接下来我们用生活中&lt;strong&gt;智能家居&lt;/strong&gt;的小例子来分析一下外观模式。智能家居为什么会流行，其中一个原因肯定是方便，我们用一个中央处理器就可以管理我们所有的智能家居产品，类似的还有现在的&lt;strong&gt;一站式服务&lt;/strong&gt;。&lt;strong&gt;那么用户就是Client角色，中央处理器就是Facade角色，音箱、TV、空调等等就是SubSystem角色。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Facade角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Facade {

    private Light mLight = new Light();
    private AirCondition mAirCondition = new AirCondition();

    /**
     * 还可能会有方法集，比如我的习惯是下班回家，开灯、开空调，空调温度调节到20度
     */
    public void doMyHabit(){
        mLight.lightOn();
        mAirCondition.airConditionaOn();
        mAirCondition.setTemperature(20);
    }

    public void lightOn(){
        mLight.lightOn();
    }

    public void lightOff(){
        mLight.lightOff();
    }

    public void airConditionaOn() {
        mAirCondition.airConditionaOn();
    }

    public void airConditionaOff() {
        mAirCondition.airConditionaOff();
    }

    public void setTemperature(int temperature) {
        mAirCondition.setTemperature(temperature);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;子系统&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Light {

    public void lightOn(){
        Log.e(&amp;quot;Light&amp;quot;,&amp;quot;on&amp;quot;);
    }

    public void lightOff(){
        Log.e(&amp;quot;Light&amp;quot;,&amp;quot;off&amp;quot;);
    }
}

public class AirCondition {

    public void airConditionaOn() {
        Log.e(&amp;quot;AirCondition&amp;quot;, &amp;quot;on&amp;quot;);
    }

    public void airConditionaOff() {
        Log.e(&amp;quot;AirCondition&amp;quot;, &amp;quot;off&amp;quot;);
    }

    public void setTemperature(int temperature) {
        Log.e(&amp;quot;AirCondition&amp;quot;, &amp;quot;temperature:&amp;quot; + temperature);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不知道大家有没有发现一个问题，外观模式和我们上篇说的适配器模式是不是有一些相似呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Facade与Adapter和Proxy有类似之处，但是Proxy注重在为Client-Subject提供一个访问的中间层，Adapter注重对接口的转换与调整，而Facade所面对的往往是多个类或其他程序单元，通过重新组合各类及程序单元，对外提供统一的接口/界面。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#Android源码中的外观模式&lt;/p&gt;
&lt;p&gt;在Android中，Context类族是比较重要的，关于这些，在&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52624483&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;从装饰者模式到Context类族&lt;/a&gt;,&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52777722&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android Handler 消息机制（解惑篇）&lt;/a&gt;中已经做过说明，这里就不再画UML图了。&lt;/p&gt;
&lt;p&gt;它是提供应用环境（application environment）信息的接口。通过它可以访问到应用的资源和类，以及进行一些系统级别的操作，比如加载activity、发送广播和接收intent等。这代表什么呢，&lt;strong&gt;Context类给我们提供了一站式服务，这里当然应用了外观模式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在应用启动时，首先会fork一个子进程，并且调用ActivityThread.main方法启动该进程。ActivityThread又会构建Application对象，然后和Activity、ContextImpl关联起来，然后再调用Activity的onCreate、onStart、onResume函数使Activity运行起来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Activity启动之后，Android给我们提供了操作系统服务的统一入口，也就是Activity本身。这些工作并不是Activity自己实现的，而是将操作委托给Activity父类ContextThemeWrapper的mBase对象，这个对象的实现类就是ContextImpl ( 也就是performLaunchActivity方法中构建的ContextImpl )。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ContextImpl内部封装了一些系统级别的操作，有的子系统功能虽然没有实现，但是也提供了访问该子系统的接口，比如获取ActivityManager的getActivityManager方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外观模式非常的简单，只是封装了子系统的操作，并且暴露接口让用户使用，避免了用户需要与多个子系统进行交互，降低了系统的耦合度、复杂度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试代码已上传到&lt;a href=&quot;https://github.com/PleaseCallMeCoder/DesignPatterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;#参考链接&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/facade/elsdnwn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/facade/elsdnwn&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; Android源码中的外观模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Android源码与设计模式" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="外观模式" scheme="http://yoursite.com/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android源码" scheme="http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Android源码中的适配器模式</title>
    <link href="http://yoursite.com/2016/10/13/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/10/13/Android源码中的适配器模式/</id>
    <published>2016-10-13T07:20:00.000Z</published>
    <updated>2016-11-10T03:01:51.405Z</updated>
    
    <content type="html">&lt;p&gt; Android源码中的适配器模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52624483&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;从装饰者模式到Context类族&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52640111&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;当观察者模式和回调机制遇上Android源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52672059&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码中的静态工厂方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52700648&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android中的工厂方法模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52755908&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码中的命令模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前段时间写了&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52640111&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;当观察者模式和回调机制遇上Android源码&lt;/a&gt;，分析了下ListView中的观察者模式，今天我们来分析下ListView部分的另一个模式，适配器模式。&lt;/p&gt;
&lt;p&gt;#定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#使用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当你想使用一个已经存在的类，而它的接口不符合你的需求；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它的父亲接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#结构&lt;/p&gt;
&lt;p&gt;适配器模式有&lt;strong&gt;类的适配器模式&lt;/strong&gt;和&lt;strong&gt;对象的适配器模式&lt;/strong&gt;两种不同的形式。&lt;/p&gt;
&lt;p&gt;##类适配器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/z2CTtCi.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##对象适配器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/TNagOhd.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可以看到，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##模式所涉及的角色有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;目标(Target)角色&lt;/strong&gt;：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;源(Adapee)角色&lt;/strong&gt;：现在需要适配的接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;适配器(Adaper)角色&lt;/strong&gt;：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#实现&lt;/p&gt;
&lt;p&gt;这里我们通过一个实例来模拟一下适配器模式。需求是这样的：IPhone7的耳机口被取消，我们怎么保证之前的耳机还能用呢？当然是需要一个转接头了，这个转接头呢，其实就类似我们的适配器。&lt;strong&gt;耳机需要的接口就是我们的目标角色，手机提供的接口就是我们的源角色，转接头当然就是适配器角色了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##类适配器&lt;/p&gt;
&lt;p&gt;目标角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface ITarget {
    //获取需要的接口
    String getRightInterface();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;源角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class IPhoneSeven {

    //获取iphone7提供的接口
    public String getInterface(){
        return &amp;quot;iphone7 interface&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;适配器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CAdapter extends IPhoneSeven implements ITarget{

    @Override
    public String getRightInterface() {
        String newInterface = getInterface();
        return suit(newInterface);
    }

    /**
     * 转换操作
     * @param newInterface
     * @return
     */
    private String suit(String newInterface) {
        return &amp;quot;3.5mm interface&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##对象适配器&lt;/p&gt;
&lt;p&gt;对象适配器的目标角色和源角色是一样的，我们就不再写了。&lt;/p&gt;
&lt;p&gt;适配器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Adapter implements ITarget {

    private IPhoneSeven mIPhoneSeven;

    public Adapter(IPhoneSeven IPhoneSeven) {
        mIPhoneSeven = IPhoneSeven;
    }

    @Override
    public String getRightInterface() {
        String newInterface = mIPhoneSeven.getInterface();
        return suit(newInterface);
    }

    /**
     * 转换操作
     * @param newInterface
     * @return
     */
    private String suit(String newInterface) {
        return &amp;quot;3.5mm interface&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#Android源码中的适配器模式&lt;/p&gt;
&lt;p&gt;Android源码中的适配器模式，最典型的无非就是ListView、GridVIew、RecyclerView等等。我们来简单分析一下ListView，其他的大同小异。&lt;/p&gt;
&lt;p&gt;我们前边在使用场景中有这么一点：&lt;strong&gt;你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口，对象适配器可以适配它的父亲接口。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这句话怎么理解呢？其实放到ListView源码中理解起来更容易一些。&lt;strong&gt;首先我们的Item View可以是有各种不同布局的，我们不可能对每一个布局都去进行匹配，但是我们可以去适配它们的父类，父类是什么，就是View类。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ListView做为client，他所需要的目标接口(target interface)就是ListAdapter，包含getCount(),getItem(),getView()等几个基本的方法，为了兼容List&lt;t&gt;,Cursor等数据类型作为数据源，还专门定义两个适配器来适配他们：ArrayAdapter和CursorAdapter。这两个适配器，说白了，就是针对目标接口对数据源进行兼容修饰。&lt;/t&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们来看下结构，以下UML图省略了部分不重要的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/46Q3HYJ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来我们看看源码中的具体实现。我们Adapter的使用时在ListView的父类，AbsListView中，我们看下注释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Base class that can be used to implement virtualized lists of items. A list does&lt;/li&gt;
&lt;li&gt;not have a spatial definition here. For instance, subclases of this class can&lt;/li&gt;
&lt;li&gt;display the content of the list in a grid, in a carousel, as stack, etc.&lt;br&gt;*/&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;AbsListView定义了集合视图的逻辑框架，比如Adapter的使用、复用Item View的逻辑、布局子视图的逻辑等，子类只需要重写特定的方法即可实现集合视图的功能。&lt;/strong&gt;我们看下代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class AbsListView extends AdapterView&amp;lt;ListAdapter&amp;gt; implements TextWatcher,
        ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener,
        ViewTreeObserver.OnTouchModeChangeListener,
        RemoteViewsAdapter.RemoteAdapterConnectionCallback {
    @Override
    protected void onAttachedToWindow() {
        super.onAttachedToWindow();

        final ViewTreeObserver treeObserver = getViewTreeObserver();
        treeObserver.addOnTouchModeChangeListener(this);
        if (mTextFilterEnabled &amp;amp;&amp;amp; mPopup != null &amp;amp;&amp;amp; !mGlobalLayoutListenerAddedFilter) {
            treeObserver.addOnGlobalLayoutListener(this);
        }

        if (mAdapter != null &amp;amp;&amp;amp; mDataSetObserver == null) {
            mDataSetObserver = new AdapterDataSetObserver();
            mAdapter.registerDataSetObserver(mDataSetObserver);

            // Data may have changed while we were detached. Refresh.
            mDataChanged = true;
            mOldItemCount = mItemCount;
            mItemCount = mAdapter.getCount();
        }
    }

    /**
     * Subclasses should NOT override this method but
     *  {@link #layoutChildren()} instead.
     */
    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        super.onLayout(changed, l, t, r, b);

        mInLayout = true;

        final int childCount = getChildCount();
        if (changed) {
            for (int i = 0; i &amp;lt; childCount; i++) {
                getChildAt(i).forceLayout();
            }
            mRecycler.markChildrenDirty();
        }

        layoutChildren();
        mInLayout = false;

        mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;

        // TODO: Move somewhere sane. This doesn&amp;apos;t belong in onLayout().
        if (mFastScroll != null) {
            mFastScroll.onItemCountChanged(getChildCount(), mItemCount);
        }
    }

    /**
     * Subclasses must override this method to layout their children.
     */
    protected void layoutChildren() {
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;首先在onAttachedToWindow()方法中调用mAdapter.getCount()，获取Item View的数量，然后调用onLayout(boolean changed, int l, int t, int r, int b)方法进行布局，从注释里也可以看到，子类对于Item View的布局需要重写layoutChildren()方法。我们看下ListView中的layoutChildren()方法。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
protected void layoutChildren() {
    try {
        //根据不同的布局模式来布局Item View
        switch (mLayoutMode) {
            //~省略部分无关代码~
            case LAYOUT_FORCE_BOTTOM:
                sel = fillUp(mItemCount - 1, childrenBottom);
                adjustViewsUpOrDown();
                break;
            case LAYOUT_FORCE_TOP:
                mFirstPosition = 0;
                sel = fillFromTop(childrenTop);
                adjustViewsUpOrDown();
                break;
            //~省略部分无关代码~
            defaule:
                break;
        }
    }
}

/**
 * Fills the list from pos up to the top of the list view.
 *
 */
private View fillUp(int pos, int nextBottom) {
    View selectedView = null;

    int end = 0;
    if ((mGroupFlags &amp;amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        end = mListPadding.top;
    }

    while (nextBottom &amp;gt; end &amp;amp;&amp;amp; pos &amp;gt;= 0) {
        // is this the selected item?
        boolean selected = pos == mSelectedPosition;
        View child = makeAndAddView(pos, nextBottom, false, mListPadding.left, selected);
        nextBottom = child.getTop() - mDividerHeight;
        if (selected) {
            selectedView = child;
        }
        pos--;
    }

    mFirstPosition = pos + 1;
    setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);
    return selectedView;
}

/**
 * Fills the list from top to bottom, starting with mFirstPosition
 */
private View fillFromTop(int nextTop) {
    mFirstPosition = Math.min(mFirstPosition, mSelectedPosition);
    mFirstPosition = Math.min(mFirstPosition, mItemCount - 1);
    if (mFirstPosition &amp;lt; 0) {
        mFirstPosition = 0;
    }
    return fillDown(mFirstPosition, nextTop);
}

/**
 * Fills the list from pos down to the end of the list view.
 */
private View fillDown(int pos, int nextTop) {
    View selectedView = null;

    int end = (mBottom - mTop);
    if ((mGroupFlags &amp;amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK) {
        end -= mListPadding.bottom;
    }

    while (nextTop &amp;lt; end &amp;amp;&amp;amp; pos &amp;lt; mItemCount) {
        // is this the selected item?
        boolean selected = pos == mSelectedPosition;
        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);

        nextTop = child.getBottom() + mDividerHeight;
        if (selected) {
            selectedView = child;
        }
        pos++;
    }

    setVisibleRangeHint(mFirstPosition, mFirstPosition + getChildCount() - 1);
    return selectedView;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;从layoutChildren()方法这一串调用来看，无非就是对应ListView的不同布局模式，一种是新数据显示在最上方，一种是把新数据显示在最下方。但是无论是哪一种方式，在循环中获取View都是通过makeAndAddView(pos, nextTop, true, mListPadding.left, selected)方法来进行的。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Obtain the view and add it to our list of children. The view can be made
 * fresh, converted from an unused view, or used as is if it was in the
 * recycle bin.
 */
private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,
        boolean selected) {
    View child;


    if (!mDataChanged) {
        // Try to use an existing view for this position
        child = mRecycler.getActiveView(position);
        if (child != null) {
            // Found it -- we&amp;apos;re using an existing child
            // This just needs to be positioned
            setupChild(child, position, y, flow, childrenLeft, selected, true);

            return child;
        }
    }

    // Make a new view for this position, or convert an unused view if possible
    child = obtainView(position, mIsScrap);

    // This needs to be positioned and measured
    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);

    return child;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;从注释了解到，这个方法是用来对我们的Item View进行缓存的。这里边又调用了obtainView(position, mIsScrap)来获取Item View，因为我们的Adapter变量是在AbsListView中，通过mAdapter来调用getView肯定也在AbsListView中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为缓存机制不是我们今天分析的重点，我们看下方法注释好了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* Get a view and have it show the data associated with the specified
* position. This is called when we have already discovered that the view is
* not available for reuse in the recycle bin. The only choices left are
* converting an old view or making a new one.
* /
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;注释说的很明确：&lt;strong&gt;获得一个View，并且使它显示特定位置的数据。同时这里会处理View的复用或者重新生成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结一下就是，&lt;strong&gt;我们在负责展示数据的集合视图（AbsListView类族）和用户提供的布局、数据之间隔了一个类，即Adapter。Adapter会返回给集合视图用户数据的数量、布局，但是它吧所有的布局都抽象成了View。这样保证了AbsListView类族的高度可定制化。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试代码已上传到&lt;a href=&quot;https://github.com/PleaseCallMeCoder/DesignPatterns&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;#参考链接&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/bboyfeiyu/article/details/43950185&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/bboyfeiyu/article/details/43950185&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.codexiu.cn/android/blog/27959/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.codexiu.cn/android/blog/27959/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; Android源码中的适配器模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Android源码与设计模式" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android源码" scheme="http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
      <category term="适配器模式" scheme="http://yoursite.com/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android Handler 消息机制（解惑篇）</title>
    <link href="http://yoursite.com/2016/10/10/Android%20Handler%20%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%EF%BC%88%E8%A7%A3%E6%83%91%E7%AF%87%EF%BC%89/"/>
    <id>http://yoursite.com/2016/10/10/Android Handler 消息机制（解惑篇）/</id>
    <published>2016-10-10T06:49:00.000Z</published>
    <updated>2016-11-10T03:11:12.980Z</updated>
    
    <content type="html">&lt;p&gt;Android Handler 消息机制（解惑篇）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#Android中的消息处理机制概述&lt;/p&gt;
&lt;p&gt;大家对于Android中的消息处理机制的用法一定都比较熟悉，至于工作原理估计不少人有研究。就像我们自己写的类我们用起来比较熟悉一样，如果我们熟悉了消息处理机制的具体实现，那么我们用起来肯定也会事半功倍。&lt;/p&gt;
&lt;p&gt;博主之前只是稍有涉猎，对其中一些地方也还心存疑虑，比如&lt;strong&gt;既然Looper.loop()里是一个死循环，那它会不会很消耗CPU呢？死循环阻塞了线程，那我们其他的事务是如何被处理的呢？Android的UI线程是在哪里被初始化的呢？&lt;/strong&gt;等等。索性今天就把他们放到一起，说道说道。&lt;/p&gt;
&lt;p&gt;##Android中线程的分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;带有消息队列，用来执行循环性任务（例如主线程、android.os.HandlerThread）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有消息时就处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;没有消息时就睡眠&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;没有消息队列，用来执行一次性任务（例如java.lang.Thread）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务一旦执行完成便退出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##带有消息队列线程概述&lt;/p&gt;
&lt;p&gt;###四要素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Message(消息)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;MessageQueue(消息队列)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Looper(消息循环)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Handler(消息发送和处理)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###四要素的交互过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/QqGpsAJ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;具体工作过程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消息队列的创建&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息循环&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息的发送&lt;/p&gt;
&lt;p&gt;  最基本的两个API&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Handler.sendMessage&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带一个Message参数，用来描述消息的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Handler.post&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带一个Runnable参数，会被转换为一个Message参数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;消息的处理&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###基于消息的异步任务接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;android.os.HandlerThread&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适合用来处于不需要更新UI的后台任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;android.os.AyncTask&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;适合用来处于需要更新UI的后台任务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#带有消息队列线程的具体实现&lt;/p&gt;
&lt;p&gt;##ThreadLocal&lt;/p&gt;
&lt;p&gt;ThreadLocal并不是一个Thread，而是Thread的&lt;strong&gt;局部变量&lt;/strong&gt;。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。&lt;/p&gt;
&lt;p&gt;从线程的角度看，目标变量就象是&lt;strong&gt;线程的本地变量&lt;/strong&gt;，这也是类名中“Local”所要表达的意思。&lt;/p&gt;
&lt;p&gt;##Looper&lt;/p&gt;
&lt;p&gt;用于在指定线程中运行一个消息循环，一旦有新任务则执行，执行完继续等待下一个任务，即变成&lt;strong&gt;Looper线程&lt;/strong&gt;。Looper类的注释里有这样一个例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class LooperThread extends Thread {

    public Handler mHandler;

    public void run() {

        //将当前线程初始化为Looper线程
        Looper.prepare();

        // ...其他处理，如实例化handler
        mHandler = new Handler() {
            public void handleMessage(Message msg) {
                // process incoming messages here
            }
        };

        // 开始循环处理消息队列
        Looper.loop();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其实核心代码就两行，我们先来看下Looper.prepare()方法的具体实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public final class Looper {

    private static final String TAG = &amp;quot;Looper&amp;quot;;

    // sThreadLocal.get() will return null unless you&amp;apos;ve called prepare().
    static final ThreadLocal&amp;lt;Looper&amp;gt; sThreadLocal = new ThreadLocal&amp;lt;Looper&amp;gt;();
    private static Looper sMainLooper;  // guarded by Looper.class

    //Looper内的消息队列
    final MessageQueue mQueue;
    // 当前线程
    final Thread mThread;

    private Printer mLogging;

    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }

     /** Initialize the current thread as a looper.
      * This gives you a chance to create handlers that then reference
      * this looper, before actually starting the loop. Be sure to call
      * {@link #loop()} after calling this method, and end it by calling
      * {@link #quit()}.
      */
    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        //试图在有Looper的线程中再次创建Looper将抛出异常
        if (sThreadLocal.get() != null) {
            throw new RuntimeException(&amp;quot;Only one Looper may be created per thread&amp;quot;);
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

    /**
     * Initialize the current thread as a looper, marking it as an
     * application&amp;apos;s main looper. The main looper for your application
     * is created by the Android environment, so you should never need
     * to call this function yourself.  See also: {@link #prepare()}
     */
    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException(&amp;quot;The main Looper has already been prepared.&amp;quot;);
            }
            sMainLooper = myLooper();
        }
    }

    //~省略部分无关代码~
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从中我们可以看到以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;prepare()其核心就是将looper对象定义为ThreadLocal&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一个Thread只能有一个Looper对象&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;prepare()方法会调用Looper的构造方法，初始化一个消息队列，并且指定当前线程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在调用Looper.loop()方法之前，确保已经调用了prepare(boolean quitAllowed)方法，并且我们可以调用quite方法结束循环&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;说到初始化MessageQueue，我们来看下它是干什么的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Low-level class holding the list of messages to be dispatched by a&lt;/li&gt;
&lt;li&gt;{@link Looper}.  Messages are not added directly to a MessageQueue,&lt;/li&gt;
&lt;li&gt;but rather through {@link Handler} objects associated with the Looper.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;You can retrieve the MessageQueue for the current thread with&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;{@link Looper#myQueue() Looper.myQueue()}.&lt;br&gt;*/&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;它是一个低等级的持有Messages集合的类，被Looper分发。Messages并不是直接加到MessageQueue的，而是通过Handler对象和Looper关联到一起。我们可以通过Looper.myQueue()方法来检索当前线程的MessageQueue。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来再看看Looper.loop()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Run the message queue in this thread. Be sure to call
 * {@link #quit()} to end the loop.
 */
public static void loop() {
    //得到当前线程Looper
    final Looper me = myLooper();
    if (me == null) {
        throw new RuntimeException(&amp;quot;No Looper; Looper.prepare() wasn&amp;apos;t called on this thread.&amp;quot;);
    }
    //得到当前looper的MessageQueue
    final MessageQueue queue = me.mQueue;

    // Make sure the identity of this thread is that of the local process,
    // and keep track of what that identity token actually is.
    Binder.clearCallingIdentity();
    final long ident = Binder.clearCallingIdentity();

    //开始循环
    for (;;) {
        Message msg = queue.next(); // might block
        if (msg == null) {
            // No message indicates that the message queue is quitting.
            //没有消息表示消息队列正在退出
            return;
        }

        // This must be in a local variable, in case a UI event sets the logger
        Printer logging = me.mLogging;
        if (logging != null) {
            logging.println(&amp;quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; Dispatching to &amp;quot; + msg.target + &amp;quot; &amp;quot; +
                    msg.callback + &amp;quot;: &amp;quot; + msg.what);
        }

        //将真正的处理工作交给message的target，即handler
        msg.target.dispatchMessage(msg);

        if (logging != null) {
            logging.println(&amp;quot;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; Finished to &amp;quot; + msg.target + &amp;quot; &amp;quot; + msg.callback);
        }

        // Make sure that during the course of dispatching the
        // identity of the thread wasn&amp;apos;t corrupted.
        final long newIdent = Binder.clearCallingIdentity();
        if (ident != newIdent) {
            Log.wtf(TAG, &amp;quot;Thread identity changed from 0x&amp;quot;
                    + Long.toHexString(ident) + &amp;quot; to 0x&amp;quot;
                    + Long.toHexString(newIdent) + &amp;quot; while dispatching to &amp;quot;
                    + msg.target.getClass().getName() + &amp;quot; &amp;quot;
                    + msg.callback + &amp;quot; what=&amp;quot; + msg.what);
        }

        //回收消息资源
        msg.recycleUnchecked();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过这段代码可知，&lt;strong&gt;调用loop方法后，Looper线程就开始真正工作了，它不断从自己的MessageQueue中取出队头的消息(或者说是任务)执行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除了prepare()和loop()方法，Looper类还有一些比较有用的方法，比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Looper.myLooper()得到当前线程looper对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;getThread()得到looper对象所属线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;quit()方法结束looper循环&lt;/p&gt;
&lt;p&gt;  这里需要注意的一点是，quit（）方法其实调用的是MessageWueue的quite（boolean safe）方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void quit(boolean safe) {
    if (!mQuitAllowed) {
        throw new IllegalStateException(&amp;quot;Main thread not allowed to quit.&amp;quot;);
    }

    synchronized (this) {
        if (mQuitting) {
            return;
        }
        mQuitting = true;

        if (safe) {
            removeAllFutureMessagesLocked();
        } else {
            removeAllMessagesLocked();
        }

        // We can assume mPtr != 0 because mQuitting was previously false.
        nativeWake(mPtr);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  &lt;strong&gt;我们看到其实主线程是不能调用这个方法退出消息队列的。至于mQuitAllowed参数是在Looper初始化的时候初始化的，主线程初始化调用的是Looper.prepareMainLooper()方法，这个方法把参数设置为false。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Message&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在整个消息处理机制中，message又叫task，封装了任务携带的信息和处理该任务的handler&lt;/strong&gt;。我们看下这个类的注释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;Defines a message containing a description and arbitrary data object that can be&lt;/li&gt;
&lt;li&gt;sent to a {@link Handler}.  This object contains two extra int fields and an&lt;/li&gt;
&lt;li&gt;extra object field that allow you to not do allocations in many cases.&lt;br&gt;*&lt;/li&gt;
&lt;li&gt;&lt;p class=&quot;note&quot;&gt;While the constructor of Message is public, the best way to get&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;one of these is to call {@link #obtain Message.obtain()} or one of the&lt;/li&gt;
&lt;li&gt;{@link Handler#obtainMessage Handler.obtainMessage()} methods, which will pull&lt;/li&gt;
&lt;li&gt;them from a pool of recycled objects.&lt;p&gt;&lt;/p&gt;&lt;br&gt;*/&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这个类定义了一个包含描述和一个任意类型对象的对象，它可以被发送给Handler。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从注释里我们还可以了解到以下几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;尽管Message有public的默认构造方法，但是你应该通过Message.obtain()来从消息池中获得空消息对象，以节省资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果你的message只需要携带简单的int信息，请优先使用Message.arg1和Message.arg2来传递信息，这比用Bundle更省内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用message.what来标识信息，以便用不同方式处理message。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Handler&lt;/p&gt;
&lt;p&gt;从MessageQueue的注释中，我们知道添加消息到消息队列是通过Handler来操作的。我们通过源码来看下具体是怎么实现的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Handler allows you to send and process {@link Message} and Runnable&lt;/li&gt;
&lt;li&gt;objects associated with a thread’s {@link MessageQueue}.  Each Handler&lt;/li&gt;
&lt;li&gt;instance is associated with a single thread and that thread’s message&lt;/li&gt;
&lt;li&gt;queue.  When you create a new Handler, it is bound to the thread /&lt;/li&gt;
&lt;li&gt;message queue of the thread that is creating it – from that point on,&lt;/li&gt;
&lt;li&gt;it will deliver messages and runnables to that message queue and execute&lt;/li&gt;
&lt;li&gt;them as they come out of the message queue.&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There are two main uses for a Handler: (1) to schedule messages and&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;runnables to be executed as some point in the future; and (2) to enqueue&lt;/li&gt;
&lt;li&gt;an action to be performed on a different thread than your own.&lt;/li&gt;
&lt;li&gt;*/&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;注释比较简单，这里就不过多翻译了，主要内容是：&lt;strong&gt;每一个Handler实例关联了一个单一的ghread和这个thread的messagequeue，当Handler的实例被创建的时候它就被绑定到了创建它的thread。它用来调度message和runnables在未来某个时间点的执行，还可以排列其他线程里执行的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Handler {

    //~省略部分无关代码~

    final MessageQueue mQueue;
    final Looper mLooper;

    public Handler() {
        this(null, false);
    }

    public Handler(Looper looper) {
        this(looper, null, false);
    }

    public Handler(boolean async) {
        this(null, async);
    }

    public Handler(Callback callback, boolean async) {
        if (FIND_POTENTIAL_LEAKS) {
            final Class&amp;lt;? extends Handler&amp;gt; klass = getClass();
            if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;amp;&amp;amp;
                    (klass.getModifiers() &amp;amp; Modifier.STATIC) == 0) {
                Log.w(TAG, &amp;quot;The following Handler class should be static or leaks might occur: &amp;quot; +
                    klass.getCanonicalName());
            }
        }

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                &amp;quot;Can&amp;apos;t create handler inside thread that has not called Looper.prepare()&amp;quot;);
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }

    public Handler(Looper looper, Callback callback, boolean async) {
        mLooper = looper;
        mQueue = looper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }

    //~省略部分无关代码~
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先看构造方法，&lt;strong&gt;其实里边的重点是初始化了两个变量，把关联looper的MessageQueue作为自己的MessageQueue，因此它的消息将发送到关联looper的MessageQueue上&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有了handler之后，我们就可以使用Handler提供的post和send系列方法向MessageQueue上发送消息了。其实&lt;strong&gt;post发出的Runnable对象最后都被封装成message对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们看一下handler是如何发送消息的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Causes the Runnable r to be added to the message queue.
 * The runnable will be run on the thread to which this handler is 
 * attached. 
 *  
 * @param r The Runnable that will be executed.
 * 
 * @return Returns true if the Runnable was successfully placed in to the 
 *         message queue.  Returns false on failure, usually because the
 *         looper processing the message queue is exiting.
 */
public final boolean post(Runnable r)
{
   return  sendMessageDelayed(getPostMessage(r), 0);
}

/**
 * Enqueue a message into the message queue after all pending messages
 * before (current time + delayMillis). You will receive it in
 * {@link #handleMessage}, in the thread attached to this handler.
 *  
 * @return Returns true if the message was successfully placed in to the 
 *         message queue.  Returns false on failure, usually because the
 *         looper processing the message queue is exiting.  Note that a
 *         result of true does not mean the message will be processed -- if
 *         the looper is quit before the delivery time of the message
 *         occurs then the message will be dropped.
 */
public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
    if (delayMillis &amp;lt; 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}

/**
 * Enqueue a message into the message queue after all pending messages
 * before the absolute time (in milliseconds) &amp;lt;var&amp;gt;uptimeMillis&amp;lt;/var&amp;gt;.
 * &amp;lt;b&amp;gt;The time-base is {@link android.os.SystemClock#uptimeMillis}.&amp;lt;/b&amp;gt;
 * Time spent in deep sleep will add an additional delay to execution.
 * You will receive it in {@link #handleMessage}, in the thread attached
 * to this handler.
 * 
 * @param uptimeMillis The absolute time at which the message should be
 *         delivered, using the
 *         {@link android.os.SystemClock#uptimeMillis} time-base.
 *         
 * @return Returns true if the message was successfully placed in to the 
 *         message queue.  Returns false on failure, usually because the
 *         looper processing the message queue is exiting.  Note that a
 *         result of true does not mean the message will be processed -- if
 *         the looper is quit before the delivery time of the message
 *         occurs then the message will be dropped.
 */
public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + &amp;quot; sendMessageAtTime() called with no mQueue&amp;quot;);
        Log.w(&amp;quot;Looper&amp;quot;, e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们只列出了一种调用关系，其他调用关系大同小异，我们来分析一下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用getPostMessage(r)，把runnable对象添加到一个Message对象中。&lt;/li&gt;
&lt;li&gt;sendMessageDelayed(getPostMessage(r), 0)，基本没做什么操作，又继续调用sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)方法，在这个方法里拿到创建这个Handler对象的线程持有的MessageQueue。&lt;/li&gt;
&lt;li&gt;调用enqueueMessage(queue, msg, uptimeMillis)方法，给msg对象的target变量赋值为当前的Handler对象，然后放入到MessageQueue。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那发送消息说完了，那我们的消息是怎样被处理的呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们看到message.target为该handler对象，这确保了looper执行到该message时能找到处理它的handler，即loop()方法中的关键代码。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Callback interface you can use when instantiating a Handler to avoid
 * having to implement your own subclass of Handler.
 *
 * @param msg A {@link android.os.Message Message} object
 * @return True if no further handling is desired
 */
public interface Callback {
    public boolean handleMessage(Message msg);
}

/**
 * Subclasses must implement this to receive messages.
 */
public void handleMessage(Message msg) {
}

/**
 * Handle system messages here.
 */
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}

private static void handleCallback(Message message) {
    message.callback.run();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;我们看到这里最终又调用到了我们重写的handleMessage(Message msg)方法来做处理子线程发来的消息或者调用handleCallback(Message message)去执行我们子线程中定义并传过来的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#思考&lt;/p&gt;
&lt;p&gt;##为什么要有Handler机制&lt;/p&gt;
&lt;p&gt;这个问题可以这么考虑&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们如何在子线程更新UI？——使用Handler机制传递消息到主线程（UI线程）&lt;/li&gt;
&lt;li&gt;为什么我们不在子线程更新UI呢？——因为Android是单线程模型&lt;/li&gt;
&lt;li&gt;为什么要做成单线程模型呢？——&lt;strong&gt;多线程并发访问UI可能会导致UI控件处于不可预期的状态。如果加锁，虽然能解决，但是缺点也很明显：1.锁机制让UI访问逻辑变得复杂；2.加锁导致效率低下。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##Handler机制与命令模式&lt;/p&gt;
&lt;p&gt;我在之前分享过&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52755908&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码中的命令模式&lt;/a&gt;，我们仔细分下一下不难看出&lt;strong&gt;Handler机制其实是一个非典型的命令模式&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;接收者：Handler，执行消息处理操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用者：Looper，调用消息的的处理方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令角色：Message，消息类。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端:Thread，创建消息并绑定Handler（接受者）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Android主线程是如何管理子线程消息的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们知道Android上一个应用的入口，应该是ActivityThread。和普通的Java类一样，入口是一个main方法。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args) {

    //~省略部分无关代码~

    //创建Looper和MessageQueue对象，用于处理主线程的消息
    Looper.prepareMainLooper();

    //创建ActivityThread对象
    ActivityThread thread = new ActivityThread();

    //建立Binder通道 (创建新线程)
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, &amp;quot;ActivityThread&amp;quot;));
    }

    // End of event ActivityThreadMain.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);

    //消息循环运行
    Looper.loop();

    throw new RuntimeException(&amp;quot;Main thread loop unexpectedly exited&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以看到其实我们在这里初始化了我们主线程（UI）的Looper并且启动它。然后就可以处理子线程和其他组件发来的消息了。&lt;/p&gt;
&lt;p&gt;##为什么主线程不会因为Looper.loop()里的死循环卡死或者不能处理其他事务&lt;/p&gt;
&lt;p&gt;这里涉及到的东西比较多，概括的理解是这样的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;为什么不会卡死&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;handler机制是使用pipe来实现的，主线程没有消息处理时会阻塞在管道的读端。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;binder线程会往主线程消息队列里添加消息，然后往管道写端写一个字节，这样就能唤醒主线程从管道读端返回，也就是说queue.next()会调用返回。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;既然是死循环又如何去处理其他事务呢？&lt;/p&gt;
&lt;p&gt; 答案是&lt;strong&gt;通过创建新线程的方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;我们看到main方法里调用了thread.attach(false)，这里便会创建一个Binder线程（具体是指ApplicationThread，Binder的服务端，用于接收系统服务AMS发送来的事件），该Binder线程通过Handler将Message发送给主线程。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;ActivityThread对应的Handler是一个内部类H，里边包含了启动Activity、处理Activity生命周期等方法。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#参考资料&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/codingmyworld/archive/2011/09/12/2174255.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://czpsailer.iteye.com/blog/655942&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://czpsailer.iteye.com/blog/655942&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/34652589&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://www.zhihu.com/question/34652589&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Android Handler 消息机制（解惑篇）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Android源码与设计模式" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="消息机制" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
    
      <category term="Handler机制" scheme="http://yoursite.com/tags/Handler%E6%9C%BA%E5%88%B6/"/>
    
      <category term="ActivityThread" scheme="http://yoursite.com/tags/ActivityThread/"/>
    
  </entry>
  
  <entry>
    <title>Android源码中的命令模式</title>
    <link href="http://yoursite.com/2016/10/08/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/10/08/Android源码中的命令模式/</id>
    <published>2016-10-08T05:41:00.000Z</published>
    <updated>2016-11-10T02:57:51.342Z</updated>
    
    <content type="html">&lt;p&gt; Android源码中的命令模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#写在前面&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52624483&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;从装饰者模式到Context类族&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52640111&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;当观察者模式和回调机制遇上Android源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52672059&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码中的静态工厂方法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52700648&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android中的工厂方法模式&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;前面跟大家分享了装饰者模式、观察者模式、静态工厂方法、工厂方法模式，今天跟大家分享下Android源码中的命令模式。&lt;/p&gt;
&lt;p&gt;#命令模式&lt;/p&gt;
&lt;p&gt;##定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##使用场景&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于大多数请求——响应模式的功能，比较适合使用命令模式。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。&lt;/li&gt;
&lt;li&gt;系统需要在不同的时间指定请求、将请求排队（&lt;strong&gt;如：线程池+工作队列&lt;/strong&gt;）和执行请求。&lt;/li&gt;
&lt;li&gt;系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作（&lt;strong&gt;比如系统挂掉之后重启做一些恢复操作，还有数据库的事务等&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;系统需要将一组操作组合在一起，即支持宏命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/hhM591V.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;命令模式涉及到的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;客户角色（Client）&lt;/strong&gt;：Client可以创建具体的命令对象，并且设置命令对象的接收者。Tips：不能把Clinet理解为我们平常说的客户端，这里的Client是一个组装命令对象和接受者对象的角色，或者你把它理解为一个装配者。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;调用者角色（Invoker）&lt;/strong&gt;：负责调用命令对象执行请求，通常会持有命令对象（可以持有多个命令对象）。Invoker是Client真正触发命令并要求命令执行相应操作的地方（使用命令对象的入口）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;命令角色（Command）&lt;/strong&gt;：定义命令的接口，声明具体命令类需要执行的方法。这是一个抽象角色。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;具体命令角色（ConcreteCommand）&lt;/strong&gt;：命令接口的具体实现对象，通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接收者角色（Receiver）&lt;/strong&gt;：Receiver是真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##实现&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命令模式其实就是对命令进行封装，将命令请求者和命令执行者的责任分离开来实现松耦合。&lt;/strong&gt; 这里我们通过一个餐厅点餐的实例来剖析一下命令模式：命令接收者Cook可以做各式各样的菜，根据Waiter送过来的订单来满足顾客的需求，具体命令实现类PigCook执行做烤乳猪命令，DuckCook执行烧花鸭命令等等，Client负责组装各个部分。&lt;/p&gt;
&lt;p&gt;命令角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Command {
    public void execute();
    public void undo();
    public void redo();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;命令接收者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Cook {

    //烤乳猪的方法
    public void cookPig(){

    }

    //烧花鸭的方法
    public void cookDuck(){

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体命令角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//做烤乳猪的命令
public class PigCook implements Command {

    private Cook mCook;

    public PigCook(Cook cook) {
        mCook = cook;
    }

    @Override
    public void execute() {
        mCook.cookPig();
    }

    @Override
    public void undo() {

    }

    @Override
    public void redo() {

    }
}
//做烧花鸭的命令
public class DuckCook implements Command {

    private Cook mCook;

    public DuckCook(Cook cook) {
        mCook = cook;
    }

    @Override
    public void execute() {
        mCook.cookDuck();
    }

    @Override
    public void undo() {

    }

    @Override
    public void redo() {

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;调用者角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Waiter {

    private Command pig;
    private Command duck;

    public void setCommandPig(Command pig) {
        this.pig = pig;
    }
    public void setCommandDuck(Command duck) {
        this.duck = duck;
    }

    /**
     * 执行正常命令，这里省略了undo和redo操作
     */
    public void invoke(int args) {
        //可以根据具体情况选择执行某些命令
        if(args == 0){
            pig.execute();
        }else if(args == 1){
            duck.execute();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;客户角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Client {
    /**
     * 组装操作
     */
    public void assembleAction() {

        //创建一个命令接收者
        Cook mCook = new Cook();

        //创建一个命令的具体实现对象，并指定命令接收者
        Command pig = new PigCook(mCook);
        Command duck = new DuckCook(mCook);

        Waiter mWaiter = new Waiter();//创建一个命令调用者
        //为调用者指定烤乳豬命令对象
        mWaiter.setCommandPig(pig);
        //为调用者指定烧花鸭命令对象
        mWaiter.setCommandDuck(duck);

        //发起调用烤乳猪命令请求
        mWaiter.invoke(0);
        //发起调用烧花鸭命令请求
        mWaiter.invoke(1);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;可是，为什么要这么复杂咧，我只是想点个菜而已嘛，直接这么搞不就好了?&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Client {
    /**
     * 组装操作
     */
    public void assembleAction() {

        //创建一个命令接收者
        Cook mCook = new Cook();

        //发起调用烤乳猪命令请求
        mCook.cookPig();
        //发起调用烧花鸭命令请求
        mCook.cookDuck();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们知道命令模式的一个优点是&lt;strong&gt;支持命令的撤销(Undo)操作和恢复(Redo)操作，&lt;/strong&gt;如果我们像上边一样调用，我们要想做撤销是不是就不那么方便了呢。同时还可以考虑下命令模式的其他几个优点。&lt;/p&gt;
&lt;p&gt;##总结&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#Android源码中的命令模式&lt;/p&gt;
&lt;p&gt;对于Android源码来说，&lt;strong&gt;Android底层逻辑对事件的转发处理就用到了命令模式&lt;/strong&gt;。Application Framework（应用程序框架层）中&lt;strong&gt;PackageManagerService&lt;/strong&gt;类（包管理部分）也用到了命令模式。PackageManagerService是Android系统的Service之一，主要功能是实现对应用包的解析、管理、卸载等操作。我们来看下具体的结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/huFpx6h.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HandlerParams是命令接口，即我们的Command角色。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private abstract class HandlerParams {
    private static final int MAX_RETRIES = 4;

    /**
     * Number of times startCopy() has been attempted and had a non-fatal
     * error.
     */
    private int mRetries = 0;

    /** User handle for the user requesting the information or installation. */
    private final UserHandle mUser;
    String traceMethod;
    int traceCookie;

    HandlerParams(UserHandle user) {
        mUser = user;
    }

    UserHandle getUser() {
        return mUser;
    }

    HandlerParams setTraceMethod(String traceMethod) {
        this.traceMethod = traceMethod;
        return this;
    }

    HandlerParams setTraceCookie(int traceCookie) {
        this.traceCookie = traceCookie;
        return this;
    }

    final boolean startCopy() {
        boolean res;
        try {
            if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;startCopy &amp;quot; + mUser + &amp;quot;: &amp;quot; + this);

            if (++mRetries &amp;gt; MAX_RETRIES) {
                Slog.w(TAG, &amp;quot;Failed to invoke remote methods on default container service. Giving up&amp;quot;);
                mHandler.sendEmptyMessage(MCS_GIVE_UP);
                handleServiceError();
                return false;
            } else {
                handleStartCopy();
                res = true;
            }
        } catch (RemoteException e) {
            if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;Posting install MCS_RECONNECT&amp;quot;);
            mHandler.sendEmptyMessage(MCS_RECONNECT);
            res = false;
        }
        handleReturnCode();
        return res;
    }

    final void serviceError() {
        if (DEBUG_INSTALL) Slog.i(TAG, &amp;quot;serviceError&amp;quot;);
        handleServiceError();
        handleReturnCode();
    }

    abstract void handleStartCopy() throws RemoteException;
    abstract void handleServiceError();
    abstract void handleReturnCode();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;具体的包的安装、移动以及包大小的测量分别在3个具体子类InstallParams、MoveParams和MeasureParams中实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而PackageHandler是Handler的子类，用来负责包相关消息的处理，不同的请求对应不同的命令对象，然后通过命令对象来执行具体操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#关于Receiver&lt;/p&gt;
&lt;p&gt;通过接触Android源码或者其他的一些源码，我们知道有些地方是没有命令接收者（Receiver）这个角色的，这是为什么呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人认为，有的命令接收实现非常简，可以直接用少量的代码来实现，没有必要再增加类的数量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/command/lijunhuayc&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/simple-android-framework/android_design_patterns_analysis/tree/master/command/lijunhuayc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/wwh578867817/article/details/51533263&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/wwh578867817/article/details/51533263&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; Android源码中的命令模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Android源码与设计模式" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android源码" scheme="http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
      <category term="命令模式" scheme="http://yoursite.com/tags/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android中的工厂方法模式</title>
    <link href="http://yoursite.com/2016/09/29/Android%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2016/09/29/Android中的工厂方法模式/</id>
    <published>2016-09-29T03:39:00.000Z</published>
    <updated>2016-11-10T03:04:36.502Z</updated>
    
    <content type="html">&lt;p&gt; Android中的工厂方法模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#写在前面的话&lt;/p&gt;
&lt;p&gt;在上一篇&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/52672059&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码中的静态工厂方法&lt;/a&gt;中我门一起研究了工厂模式三兄弟中最简单的静态工厂方法。今天我们来一起看看三兄弟中的老二————工厂方法模式，以及它在Android源码中的体现。&lt;/p&gt;
&lt;p&gt;今天我们先来模拟一个场景，把这三兄弟拎出来给大家瞅瞅，以免以后大家认错。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;今天我们决定进军手机行业，手机名字叫做aPhone。我们要做一个aPhone1的样品。————我们的直接new一个aPhone1对象就好了&lt;/li&gt;
&lt;li&gt;我们的aPhone1卖的巨火，挡都挡不住，我们要出aPhone2、aPhone3、aPhone4等等一系列手机。————我们可以通过简单工厂方法来生产手机（老三）&lt;/li&gt;
&lt;li&gt;我们的aPhone系列手机配置比较高，考虑到市场上对低端产品的需求，我们要做aPhoneNote系列手机。————我们可以通过工厂方法模式来生产（老二）&lt;/li&gt;
&lt;li&gt;由于我们aPhone6系列手机的屏幕生产时出现了问题，导致手机寿命降低，给公司造成了很大的损失。现在我们要从零件方面来把控产品质量，屏幕、电池、主板等零件的质量我们都要做质检。————我们可以通过抽象工厂来生产（老大）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这就是工厂三兄弟。&lt;/p&gt;
&lt;p&gt;#工厂方法模式&lt;/p&gt;
&lt;p&gt;##定义&lt;/p&gt;
&lt;p&gt;工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工厂方法模式的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/reYCVr1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;工厂方法模式所涉及到的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Product（抽象产品角色）&lt;/strong&gt;：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteProduct（具体产品角色）&lt;/strong&gt;：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Factory(抽象工厂角色)&lt;/strong&gt;：这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteFactory（具体工厂角色）&lt;/strong&gt;：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##实现&lt;/p&gt;
&lt;p&gt;我们用我们上边手机的例子来实现。&lt;/p&gt;
&lt;p&gt;抽象产品角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class APhone {  
    //所有产品类的公共业务方法  
    public void methodSame() {  
        //公共方法的实现  
    }  

    //声明抽象业务方法  
    public abstract void methodDiff();  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体产品角色类，这里我们只说一类，比如我们的aPhoneNote系列手机&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class APhoneNote1 extends APhone {  
    //实现业务方法  
    public void methodDiff() {  
        //业务方法的实现  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;抽象工厂角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class Factory {  
    //静态工厂方法  
    public abstract APhone createProduct(String arg)；
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体工厂角色，这里我们只说生产aPhoneNote系列手机的工厂&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ConcreteFactory {  
    //静态工厂方法  
    public APhone createProduct(String arg) {  
        APhone aPhoneNote = null;  
        if (arg.equalsIgnoreCase(&amp;quot;1&amp;quot;)) {  
            aPhoneNote = new APhoneNote1();  
            //初始化设置product  
        }  
        else if (arg.equalsIgnoreCase(&amp;quot;2)) {  
            aPhoneNote = new APhoneNote2();  
            //初始化设置product  
        }  
        return aPhoneNote;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##使用场景&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;需要创建复杂对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;需要灵活、可扩展的框架，且具体类型不多&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#Android中工厂方法模式的应用&lt;/p&gt;
&lt;p&gt;##Java中的类集框架&lt;/p&gt;
&lt;p&gt;我们在开发中会用到很多数据结构，比如ArrayList，HashMap等。我们先来看下Java中Collection部分的类集框架的简要UML图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/yHO5stJ.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们知道Iterator是迭代器，用来遍历一个集合中的元素。而不同的数据结构遍历的方式是不一样的，所以迭代器的实现也是不同的。使用工厂方法模式将迭代器的具体类型延迟到具体容器类中，比较灵活，容易扩展。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;List和Set继承自Collection接口，Collection接口继承于Iterable接口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Iterable&amp;lt;T&amp;gt; {
    /**
     * Returns an iterator over elements of type {@code T}.
     *
     * @return an Iterator.
     */
    Iterator&amp;lt;T&amp;gt; iterator();

    //省略部分代码
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以List和Set接口也会继承该方法。然后我们常用的两个间接实现类ArrayList和HashSet中的iterator方法就给我们构造并返回了一个迭代器对象。&lt;/p&gt;
&lt;p&gt;我们找到ArrayList类，查看iterator方法的实现。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override 
public Iterator&amp;lt;E&amp;gt; iterator() {
    return new ArrayListIterator();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ArrayListIterator类型定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private class ArrayListIterator implements Iterator&amp;lt;E&amp;gt; {
    /** Number of elements remaining in this iteration */
    private int remaining = size;

    /** Index of element that remove() would remove, or -1 if no such elt */
    private int removalIndex = -1;

    /** The expected modCount value */
    private int expectedModCount = modCount;

    public boolean hasNext() {
        return remaining != 0;
    }

    @SuppressWarnings(&amp;quot;unchecked&amp;quot;) public E next() {
        ArrayList&amp;lt;E&amp;gt; ourList = ArrayList.this;
        int rem = remaining;
        if (ourList.modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        if (rem == 0) {
            throw new NoSuchElementException();
        }
        remaining = rem - 1;
        return (E) ourList.array[removalIndex = ourList.size - rem];
    }

    public void remove() {
        Object[] a = array;
        int removalIdx = removalIndex;
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        if (removalIdx &amp;lt; 0) {
            throw new IllegalStateException();
        }
        System.arraycopy(a, removalIdx + 1, a, removalIdx, remaining);
        a[--size] = null;  // Prevent memory leak
        removalIndex = -1;
        expectedModCount = ++modCount;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看到这个类实现了Iterator接口，接口的定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Iterator&amp;lt;E&amp;gt; {

    boolean hasNext();

    E next();

    default void remove() {
        throw new UnsupportedOperationException(&amp;quot;remove&amp;quot;);
    }

    default void forEachRemaining(Consumer&amp;lt;? super E&amp;gt; action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们基本的结构也分析完了，接下来对号入座，看一看具体是如何实现工厂方法模式的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Iterator————&amp;gt;Product;ArrayListIteratorr————&amp;gt;ConcreteProduct。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Iterable/List————&amp;gt;Factory；ArrayList————&amp;gt;ConcreteFactory。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工厂方法使一个类的实例化延迟到子类，对应着将迭代器Iterator的创建从List延迟到了ArrayList。&lt;/strong&gt;这就是工厂方法模式。&lt;/p&gt;
&lt;p&gt;##瞎总结&lt;/p&gt;
&lt;p&gt;看是看完了，但是，总要给我们一个这么做的理由吧？&lt;/p&gt;
&lt;p&gt;个人认为，这样设计使得我们的&lt;strong&gt;代码结构变得更清晰，同是比较容易扩展&lt;/strong&gt;，因为我们已经定义好了一套标准，只要按照规矩来就好了。&lt;/p&gt;
&lt;p&gt;同时&lt;strong&gt;耦合度降低&lt;/strong&gt;了，高层模块只需要知道产品的抽象类，无所谓具体怎么实现这个产品。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; Android中的工厂方法模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Android源码与设计模式" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android源码" scheme="http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
      <category term="工厂方法模式" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android源码中的静态工厂方法</title>
    <link href="http://yoursite.com/2016/09/26/Android%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/09/26/Android源码中的静态工厂方法/</id>
    <published>2016-09-26T09:20:00.000Z</published>
    <updated>2016-11-10T02:56:18.799Z</updated>
    
    <content type="html">&lt;p&gt; Android源码中的静态工厂方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们知道工厂模式有三兄弟，通常我们说的工厂模式指的是工厂方法模式，它的应用频率最高。本篇博客分享的简单工厂模式是工厂方法模式的“小弟”，确切的来讲它不属于设计模式，而是一种方法。此外，工厂方法模式还有一位“大哥”——抽象工厂模式。&lt;/p&gt;
&lt;p&gt;今天我们来分享一下简单工厂模式的一些情况，以及它在Android源码中的应用。&lt;/p&gt;
&lt;p&gt;#简单工厂模式&lt;/p&gt;
&lt;p&gt;##定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/iLCpogO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单工厂模式所涉及到的角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Product（抽象产品角色）&lt;/strong&gt;：产品的通用接口，定义产品的行为。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ConcreteProduct（具体产品角色）&lt;/strong&gt;：具体产品类，实现了Product接口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Creator（工厂角色）&lt;/strong&gt;：工厂类，通过静态工厂方法factoryMethord来创建对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##实现&lt;/p&gt;
&lt;p&gt;抽象产品角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;abstract class Product {  
    //所有产品类的公共业务方法  
    public void methodSame() {  
        //公共方法的实现  
    }  

    //声明抽象业务方法  
    public abstract void methodDiff();  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体产品角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class ConcreteProduct extends Product {  
    //实现业务方法  
    public void methodDiff() {  
        //业务方法的实现  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;工厂角色&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Creator {  
    //静态工厂方法  
    public static Product getProduct(String arg) {  
        Product product = null;  
        if (arg.equalsIgnoreCase(&amp;quot;A&amp;quot;)) {  
            product = new ConcreteProductA();  
            //初始化设置product  
        }  
        else if (arg.equalsIgnoreCase(&amp;quot;B&amp;quot;)) {  
            product = new ConcreteProductB();  
            //初始化设置product  
        }  
        return product;  
    }  
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##使用场景&lt;/p&gt;
&lt;p&gt;在以下情况下可以考虑使用简单工厂模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。&lt;/li&gt;
&lt;li&gt;客户端只知道传入工厂类的参数，对于如何创建对象并不关心。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##优点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度减少使用者的记忆量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##缺点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。&lt;/li&gt;
&lt;li&gt;简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Android中简单工厂模式的应用&lt;/p&gt;
&lt;p&gt;在Android中我们了解的使用到了简单工厂方法的地方有Bitmap对象的获取、Fragment创建等。接下来我们分开看一下。&lt;/p&gt;
&lt;p&gt;###Bitmap源码分析 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先来说我们是不能通过new方法来创建Bitmap对象的，因为从源码中可以看到Bitmap的类名是通过final来修饰的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们随便找个入口开始看，比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Bitmap bmp = BitmapFactory.decodeFile(String pathName);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们把源码中的调用关系找出来，如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static Bitmap decodeFile(String pathName) {
    return decodeFile(pathName, null);
}

public static Bitmap decodeFile(String pathName, Options opts) {
    Bitmap bm = null;
    InputStream stream = null;
    try {
        stream = new FileInputStream(pathName);
        bm = decodeStream(stream, null, opts);
    } catch (Exception e) {
        /*  do nothing.
            If the exception happened on open, bm will be null.
        */
        Log.e(&amp;quot;BitmapFactory&amp;quot;, &amp;quot;Unable to decode stream: &amp;quot; + e);
    } finally {
        if (stream != null) {
            try {
                stream.close();
            } catch (IOException e) {
                // do nothing here
            }
        }
    }
    return bm;
}

public static Bitmap decodeStream(InputStream is, Rect outPadding, Options opts) {
    // we don&amp;apos;t throw in this case, thus allowing the caller to only check
    // the cache, and not force the image to be decoded.
    if (is == null) {
        return null;
    }

    Bitmap bm = null;

    Trace.traceBegin(Trace.TRACE_TAG_GRAPHICS, &amp;quot;decodeBitmap&amp;quot;);
    try {
        if (is instanceof AssetManager.AssetInputStream) {
            final long asset = ((AssetManager.AssetInputStream) is).getNativeAsset();
            bm = nativeDecodeAsset(asset, outPadding, opts);
        } else {
            bm = decodeStreamInternal(is, outPadding, opts);
        }

        if (bm == null &amp;amp;&amp;amp; opts != null &amp;amp;&amp;amp; opts.inBitmap != null) {
            throw new IllegalArgumentException(&amp;quot;Problem decoding into existing bitmap&amp;quot;);
        }

        setDensityFromOptions(bm, opts);
    } finally {
        Trace.traceEnd(Trace.TRACE_TAG_GRAPHICS);
    }

    return bm;
}

private static native Bitmap nativeDecodeStream(InputStream is, byte[] storage,
        Rect padding, Options opts);

/**
 * Set the newly decoded bitmap&amp;apos;s density based on the Options.
 */
private static void setDensityFromOptions(Bitmap outputBitmap, Options opts) {
    if (outputBitmap == null || opts == null) return;

    final int density = opts.inDensity;
    if (density != 0) {
        outputBitmap.setDensity(density);
        final int targetDensity = opts.inTargetDensity;
        if (targetDensity == 0 || density == targetDensity || density == opts.inScreenDensity) {
            return;
        }

        byte[] np = outputBitmap.getNinePatchChunk();
        final boolean isNinePatch = np != null &amp;amp;&amp;amp; NinePatch.isNinePatchChunk(np);
        if (opts.inScaled || isNinePatch) {
            outputBitmap.setDensity(targetDensity);
        }
    } else if (opts.inBitmap != null) {
        // bitmap was reused, ensure density is reset
        outputBitmap.setDensity(Bitmap.getDefaultDensity());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们来分析一下调用过程，可以看到&lt;strong&gt;decodeFile(String pathName)调用的是decodeFile(String pathName, Options opts)，在两个参数的decodeFile方法中又去调用了decodeStream(InputStream is, Rect outPadding, Options opts)方法，然后最终调用nativeDecodeAsset或者nativeDecodeStream来构建Bitmap对象，这两个都是native方法(Android中使用Skia库来解析图像 )。再经过setDensityFromOptions方法的一些设置解码密度之类的操作，返回我们要的Bitmap对象。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Creates Bitmap objects from various sources, including files, streams, and byte-arrays.&lt;br&gt;*/&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;看下BitmapFactory的注释我们可以看到，这个工厂支持从不同的资源创建Bitmap对象，包括files, streams, 和byte-arrays，但是调用关系都大同小异。&lt;/p&gt;
&lt;p&gt;##Fragment创建&lt;/p&gt;
&lt;p&gt;有时候，为了简化简单工厂模式，我们可以将抽象产品类和工厂类合并，将静态工厂方法移至抽象产品类中。Fragment的创建使用简单工厂方法没有抽象产品类，所以工厂类放到了实现产品类中。&lt;/p&gt;
&lt;p&gt;在AndroidStudio中输入newInstance会自动补全Fragment的简单工厂方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static TasksFragment newInstance() {

    Bundle args = new Bundle();

    TasksFragment fragment = new TasksFragment();
    fragment.setArguments(args);
    return fragment;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;使用静态工厂方法，将外部传入的参数可以通过Fragment.setArgument保存在它自己身上，这样我们可以在Fragment.onCreate(…)调用的时候将这些参数取出来。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样写有什么好处呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;避免了在创建Fragment的时候无法在类外部知道所需参数的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fragment推荐使用setArguments来传递参数，避免在横竖屏切换的时候Fragment自动调用自己的无参构造函数，导致数据丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; Android源码中的静态工厂方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Android源码与设计模式" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android源码" scheme="http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
      <category term="静态工厂方法" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>当观察者模式和回调机制遇上Android源码</title>
    <link href="http://yoursite.com/2016/09/23/%E5%BD%93%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E9%81%87%E4%B8%8AAndroid%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2016/09/23/当观察者模式和回调机制遇上Android源码/</id>
    <published>2016-09-23T08:54:00.000Z</published>
    <updated>2016-11-10T03:07:49.749Z</updated>
    
    <content type="html">&lt;p&gt; 当观察者模式和回调机制遇上Android源码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上一篇博客跟大家分享了Android源码中的装饰者模式，有点意犹未尽，今天跟大家分享下Android中的观察者模式，顺便说一说观察者模式和回调机制的关系，欢迎大家拍砖。&lt;/p&gt;
&lt;p&gt;#观察者模式&lt;/p&gt;
&lt;p&gt;##定义&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##观察者模式的结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Jbw7PMO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;观察者模式所涉及的角色有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。　　&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。
　　&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态 像协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##实现&lt;/p&gt;
&lt;p&gt;抽象主题角色类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public abstract class Subject {
    /**
     * 用来保存注册的观察者对象
     */
    private    List&amp;lt;Observer&amp;gt; list = new ArrayList&amp;lt;Observer&amp;gt;();
    /**
     * 注册观察者对象
     * @param observer    观察者对象
     */
    public void attach(Observer observer){

        list.add(observer);
        System.out.println(&amp;quot;Attached an observer&amp;quot;);
    }
    /**
     * 删除观察者对象
     * @param observer    观察者对象
     */
    public void detach(Observer observer){

        list.remove(observer);
    }
    /**
     * 通知所有注册的观察者对象
     */
    public void nodifyObservers(String newState){

        for(Observer observer : list){
            observer.update(newState);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体主题角色类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ConcreteSubject extends Subject{

    private String state;

    public String getState() {
        return state;
    }

    public void change(String newState){
        state = newState;
        System.out.println(&amp;quot;主题状态为：&amp;quot; + state);
        //状态发生改变，通知各个观察者
        this.nodifyObservers(state);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;抽象观察者角色类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Observer {
    /**
     * 更新接口
     * @param state    更新的状态
     */
    public void update(String state);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体观察者角色类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ConcreteObserver implements Observer {
    //观察者的状态
    private String observerState;

    @Override
    public void update(String state) {
        /**
         * 更新观察者的状态，使其与目标的状态保持一致
         */
        observerState = state;
        System.out.println(&amp;quot;状态为：&amp;quot;+observerState);
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试类&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Test {

    public static void main(String[] args) {
        //创建主题对象
        ConcreteSubject subject = new ConcreteSubject();
        //创建观察者对象
        Observer observer = new ConcreteObserver();
        //将观察者对象登记到主题对象上
        subject.attach(observer);
        //改变主题对象的状态
        subject.change(&amp;quot;new state&amp;quot;);
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#观察者的两种实现方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Push&lt;/p&gt;
&lt;p&gt;  主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Pull&lt;/p&gt;
&lt;p&gt;  主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##两种方式的比较&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Push模型是假定主题对象知道观察者需要的数据；而Pull模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Push模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而Pull模型就不会造成这样的情况，因为Pull模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#回调机制和观察者模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android中有非常多的地方使用了回调机制，例如Activity的生命周期、按钮的点击事件、线程的run()方法等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面是回调的基本模型：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface CallBack {  
    public void oncall();  
}  

public class A {  
    private CallBack callback;  
    //注册一个事件  
    public void register(CallBack callback){  
        this.callback = callback;  
    }  
    // 需要调用的时候回调  
    public void call(){  
        callback.oncall();  
    }  
}  

public static void main(String[] args) {  
    A a = new A();  
    a.register(new CallBack() {  
        @Override  
        public void oncall() {  
            System.out.println(&amp;quot;回调函数被调用&amp;quot;);  
        }  
    });  
    a.call();  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;}  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这样看来，回调机制和观察者模式是一致的，区别是观察者模式里面目标类维护了所有观察者的引用，而回调里面只是维护了一个引用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#Android中的观察者模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android中大量的使用了观察者模式，Framework层里面的事件驱动都是基于观察者模式实现的。另外在Framework层里面的各种服务在数据变更的时候，也是通过观察者模式实现上层数据更新的。像View的Listener监听、GPS位置信息监听、BroadcastReceiver等都是基于观察者模式实现的。&lt;/strong&gt;下面我们说一说ListView中的观察者模式是如何实现的，RecyclerView大同小异，感兴趣的可以自己研究下。&lt;/p&gt;
&lt;p&gt;##Listview的notifyDataSetChanged()&lt;/p&gt;
&lt;p&gt;我们先来看下listview部分观察者模式的结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/M5Gf0MO.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其中为了方便研究关系，我们省略了Adapter部分的一些类的关系。接下来我们看下具体调用关系。&lt;/p&gt;
&lt;p&gt;首先当我们数据改变的时候我们会调用adapter的notifyDataSetChanged()方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * Common base class of common implementation for an {@link Adapter} that can be
 * used in both {@link ListView} (by implementing the specialized
 * {@link ListAdapter} interface) and {@link Spinner} (by implementing the
 * specialized {@link SpinnerAdapter} interface).
 */
public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter {
    private final DataSetObservable mDataSetObservable = new DataSetObservable();

    public boolean hasStableIds() {
        return false;
    }

    public void registerDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.registerObserver(observer);
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }

    /**
     * Notifies the attached observers that the underlying data has been changed
     * and any View reflecting the data set should refresh itself.
     */
    public void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }

    /**
     * Notifies the attached observers that the underlying data is no longer valid
     * or available. Once invoked this adapter is no longer valid and should
     * not report further data set changes.
     */
    public void notifyDataSetInvalidated() {
        mDataSetObservable.notifyInvalidated();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据上述代码我们可以定位到mDataSetObservable.notifyChanged()方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * A specialization of {@link Observable} for {@link DataSetObserver}
 * that provides methods for sending notifications to a list of
 * {@link DataSetObserver} objects.
 */
public class DataSetObservable extends Observable&amp;lt;DataSetObserver&amp;gt; {
    /**
     * Invokes {@link DataSetObserver#onChanged} on each observer.
     * Called when the contents of the data set have changed.  The recipient
     * will obtain the new contents the next time it queries the data set.
     */
    public void notifyChanged() {
        synchronized(mObservers) {
            // since onChanged() is implemented by the app, it could do anything, including
            // removing itself from {@link mObservers} - and that could cause problems if
            // an iterator is used on the ArrayList {@link mObservers}.
            // to avoid such problems, just march thru the list in the reverse order.
            for (int i = mObservers.size() - 1; i &amp;gt;= 0; i--) {
                mObservers.get(i).onChanged();
            }
        }
    }

    /**
     * Invokes {@link DataSetObserver#onInvalidated} on each observer.
     * Called when the data set is no longer valid and cannot be queried again,
     * such as when the data set has been closed.
     */
    public void notifyInvalidated() {
        synchronized (mObservers) {
            for (int i = mObservers.size() - 1; i &amp;gt;= 0; i--) {
                mObservers.get(i).onInvalidated();
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看到，调用notifyChanged()方法，会去遍历mObservers，调用所有观察者的onchange（）方法。&lt;/p&gt;
&lt;p&gt;那么问题来了，我们的观察者对象是什么时候添加进去的呢？我们去看下ListView第一次和BaseAdapter产生关联的地方，也就是setAdapter(ListAdapter adapter)方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void setAdapter(ListAdapter adapter) {
    //如果已经设置过了Adapter，那么取消注册对应的观察者。
    if (mAdapter != null &amp;amp;&amp;amp; mDataSetObserver != null) {
        mAdapter.unregisterDataSetObserver(mDataSetObserver);
    }

    //省略部分代码

    if (mAdapter != null) {
        mAreAllItemsSelectable = mAdapter.areAllItemsEnabled();
        mOldItemCount = mItemCount;
        mItemCount = mAdapter.getCount();
        checkFocus();

        //创建一个对应数据的观察者
        mDataSetObserver = new AdapterDataSetObserver();
        //间接调用DataSetObservable的注册方法
        mAdapter.registerDataSetObserver(mDataSetObserver);

        //省略部分代码
    } else {
        mAreAllItemsSelectable = true;
        checkFocus();
        // Nothing selected
        checkSelectionChanged();
    }

    requestLayout();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们的四个角色就全了，&lt;strong&gt;Observable—&amp;gt;Subject;DataSetObservable—&amp;gt;Concrete Subject;DataSetObserver—&amp;gt;Observer;AdapterDataSetObserver—&amp;gt;Concrete Observer&lt;/strong&gt;。然后我们注册的地方也找到了。&lt;/p&gt;
&lt;p&gt;最后就剩下我们的数据是如何刷新这一个问题了。AdapterDataSetObserver定义在ListView的父类AbsListView中，它又继承自AbsListView的父类AdapterView的AdapterDataSetObserver。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class AdapterDataSetObserver extends DataSetObserver {

    private Parcelable mInstanceState = null;
    //当我们调用Adapter的notifyDataSetChanged的时候会调用所有观察者的onChanged方法,核心实现就在这里
    @Override
    public void onChanged() {
        mDataChanged = true;
        mOldItemCount = mItemCount;
        // 获取Adapter中数据的数量
        mItemCount = getAdapter().getCount();

        // Detect the case where a cursor that was previously invalidated has
        // been repopulated with new data.
        if (AdapterView.this.getAdapter().hasStableIds() &amp;amp;&amp;amp; mInstanceState != null
                &amp;amp;&amp;amp; mOldItemCount == 0 &amp;amp;&amp;amp; mItemCount &amp;gt; 0) {
            AdapterView.this.onRestoreInstanceState(mInstanceState);
            mInstanceState = null;
        } else {
            rememberSyncState();
        }
        checkFocus();
        // 重新布局ListView、GridView等AdapterView组件
        requestLayout();
    }

    // 代码省略

    public void clearSavedState() {
        mInstanceState = null;
    }
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;requestLayout()方法在View里有实现，子View按需求重写。我们看下注释好了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/&lt;em&gt;*Call this when something has changed which has invalidated the layout of this view. This will schedule a layout pass of the view tree.&lt;/em&gt;/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，到这里所有的调用关系我们基本就搞清楚了。&lt;strong&gt;当ListView的数据发生变化时，调用Adapter的notifyDataSetChanged函数，这个函数又会调用DataSetObservable的notifyChanged函数，这个函数会调用所有观察者 (AdapterDataSetObserver) 的onChanged方法。在onChanged函数中会获取Adapter中数据集的新数量，然后调用ListView的requestLayout()方法重新进行布局，更新用户界面。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#瞎总结&lt;/p&gt;
&lt;p&gt;ListView主要运用了Adapter和观察者模式使得可扩展性、灵活性非常强，而耦合度却很低，这是我认为设计模式在Android源码中优秀运用的典范。那我们就要开始思考了，&lt;strong&gt;我们有没有其他更漂亮的套路来实现ListView组件，我们可以把这件实现思路应用到哪里？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;人是会思考的芦苇，思考着思考着我们就成为了别人眼中的大神。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.itdadao.com/articles/c15a265623p0.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.itdadao.com/articles/c15a265623p0.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/bboyfeiyu/article/details/44040533&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/bboyfeiyu/article/details/44040533&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/mythou/p/3370340.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/mythou/p/3370340.html&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; 当观察者模式和回调机制遇上Android源码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Android源码与设计模式" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android源码" scheme="http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
      <category term="观察者模式" scheme="http://yoursite.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="回调机制" scheme="http://yoursite.com/tags/%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>从装饰者模式到Context类族</title>
    <link href="http://yoursite.com/2016/09/22/%E4%BB%8E%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%88%B0Context%E7%B1%BB%E7%B0%87/"/>
    <id>http://yoursite.com/2016/09/22/从装饰者模式到Context类簇/</id>
    <published>2016-09-22T08:40:00.000Z</published>
    <updated>2016-11-10T03:06:59.437Z</updated>
    
    <content type="html">&lt;p&gt; 从装饰者模式到Context类族&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本着不学习就要落后，落后就要挨打的态度，我也开始捣鼓起了设计模式。但只看设计模式又不免有些索然无味，索性就连Android源码也一起研究研究，现在看来效果不错。昨天晚上刚看了装饰者模式，正好今天总结一番分享给大家。新手上路，如有不足之处，还请大家多指教。&lt;/p&gt;
&lt;p&gt;#装饰者模式&lt;/p&gt;
&lt;p&gt;Decorator模式（别名Wrapper）：动态将职责附加到对象上，若要扩展功能，装饰者提供了比继承更具弹性的代替方案。&lt;/p&gt;
&lt;p&gt;##遵循的设计原则&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;多用组合，少用继承。&lt;/p&gt;
&lt;p&gt; 利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;类应设计的对扩展开放，对修改关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##实现&lt;/p&gt;
&lt;p&gt;装饰者的UML图大概如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/gLypqDf.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在装饰模式结构图中包含如下几个角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。&lt;/li&gt;
&lt;li&gt;Concrete Component（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。&lt;/li&gt;
&lt;li&gt;Decorator（抽象装饰类）：它也是抽象构件类的子类，抽象装饰类不一定是抽象方法。用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。&lt;/li&gt;
&lt;li&gt;Concrete Decorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们对应UML图实现就好。&lt;/p&gt;
&lt;p&gt;我们先定义一个Component，可以是接口也可以是抽象类：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface Component
{
    void operation();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来是Concrete Component：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ConcreteComponent implements Component
{
    public void operation()
    {
        // Write your code here
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后是Decorator：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Decorator implements Component
{
    private Component component;

    public Decorator(Component component)
    {
        this.component = component;
    }

    public void operation()
    {
        component.operation();
    }

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后是Concrete Decorator：&lt;/p&gt;
&lt;p&gt;在Concrete Component的行为之前或之后，加上自己的行为，以“贴上”附加的职责。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class ConcreteDecorator extends Decorator
{
    public void operation()
    {
        //addBehavior也可以在前面

        super.operation();

        addBehavior();
    }

    private void addBehavior()
    {
        //your code
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##优点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Decorator模式与继承关系的目的都是要扩展对象的功能，但是Decorator可以提供比继承更多的灵活性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#Context类簇中装饰者模式的实现&lt;/p&gt;
&lt;p&gt;有句话叫“没吃过猪肉，还没见过猪跑么？”。我们可能没有自己在代码中应用过装饰者模式，但是我们一定见过（可能当时不认识）。比如java中的I/O库，以及Android中的Context的设计等等。接下来我们看看Context是如何组织的。&lt;/p&gt;
&lt;p&gt;##uml图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/HbXf8Lt.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;中间省略了部分类，比如ContextWrapper的实现类里边还有MutableContextWrapper、BackupAgent类等，感兴趣的朋友可以自己研究一下。&lt;/p&gt;
&lt;p&gt;##Context类&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Interface to global information about an application environment.  This is an abstract class whose implementation is provided by the Android system.  It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities,broadcasting and receiving intents, etc.&lt;br&gt;*/&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;注释的意思大概是这样的：这是一个由Android系统提供其实现的抽象类，它是提供应用环境（application environment）信息的接口。通过它可以访问到应用的资源和类，以及进行一些系统级别的操作，比如加载activity、发送广播和接收intent等。&lt;/p&gt;
&lt;p&gt;粗略浏览一下里边的属性和方法，我们还可以看到一些熟悉的东西，比如getSharedPreferences（String name, int mode），以及mode参数的几种可选值；再比如getColor(@ColorRes int id)、getDrawable(@DrawableRes int id)等获取系统资源的方法等等。&lt;strong&gt;可以这样说，Content类是application的管家，它有权管理application的大部分资源。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个类对应装饰者模式中的Component。&lt;/p&gt;
&lt;p&gt;##Context的实现类&lt;/p&gt;
&lt;p&gt;###ContextImpl类&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/&lt;em&gt;*Common implementation of Context API, which provides the base context object for Activity and other application components.
 &lt;/em&gt;/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ContextImpl是Context抽象类的一个直接子类，有一个私有的构造方法，&lt;strong&gt;是Context的具体实现类&lt;/strong&gt;。源码位于android.app包中，但它在API文档中找不到，是一个默认访问权限的类，也就是说它只允许android.app包中的类可以调用它，或者只有和它同包的类才可以通过其父类的方法使用它。&lt;strong&gt;它为Activity、Service等应用组件提供基本的context对象。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个类对应装饰者模式中的Concrete Component。&lt;/p&gt;
&lt;p&gt;###ContextWrapper&lt;br&gt;    /**&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; * Proxying implementation of Context that simply delegates all of its calls to
 * another Context.  Can be subclassed to modify behavior without changing
 * the original Context.
 */
public class ContextWrapper extends Context {
    Context mBase;

    public ContextWrapper(Context base) {
        mBase = base;
    }

    /**
     * Set the base context for this ContextWrapper.  All calls will then be
     * delegated to the base context.  Throws
     * IllegalStateException if a base context has already been set.
     * 
     * @param base The new base context for this wrapper.
     */
    protected void attachBaseContext(Context base) {
        if (mBase != null) {
            throw new IllegalStateException(&amp;quot;Base context already set&amp;quot;);
        }
        mBase = base;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注释描述的很明显：&lt;strong&gt;Context类的代理实现，ContextWrapper中实现Context的方法全是通过mBase来实现的。这样它（ContextWrapper）派生出的子类就可以在不改变原始context（mBase）的情况下扩展Context的行为。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个类对应装饰者模式中的Decorator。&lt;/p&gt;
&lt;p&gt;###具体扩展&lt;/p&gt;
&lt;p&gt;这里我们就不做过多的分析了，我们简单看下Activity的父类ContextThemeWrapper。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;/**&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A context wrapper that allows you to modify or replace the theme of the wrapped context.&lt;br&gt;*/&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;注释中说的很清楚，这个类扩展的功能就是允许我们去修改或者替换包装的context的主题。&lt;/p&gt;
&lt;p&gt;我们再来看看setTheme(int resid)方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void setTheme(int resid) {
    if (mThemeResource != resid) {
        mThemeResource = resid;
        initializeTheme();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里我们没有调用父类的实现，而是自己处理了设置主题的逻辑。这样我们就用组合的方式扩展了ContextImpl中的setTeme（int resid）方法。&lt;/p&gt;
&lt;p&gt;这个类对应装饰者模式中的Concrete Decorator。其他的Service和Application等都大同小异，只不过扩展了不同的行为。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://grepcode.com/project/repository.grepcode.com/java/ext/com.google.android/android/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android源码在线查看&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/yanbober/article/details/45967639&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/yanbober/article/details/45967639&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt; 从装饰者模式到Context类族&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="Android源码与设计模式" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android源码" scheme="http://yoursite.com/tags/Android%E6%BA%90%E7%A0%81/"/>
    
      <category term="装饰者模式" scheme="http://yoursite.com/tags/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>由面试想到的</title>
    <link href="http://yoursite.com/2016/09/02/%E7%94%B1%E9%9D%A2%E8%AF%95%E6%83%B3%E5%88%B0%E7%9A%84/"/>
    <id>http://yoursite.com/2016/09/02/由面试想到的/</id>
    <published>2016-09-02T06:54:00.000Z</published>
    <updated>2016-09-06T06:14:42.105Z</updated>
    
    <content type="html">&lt;p&gt;由面试想到的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/s5MsBzS.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;尚未功成名就，如何衣锦还乡。&lt;/p&gt;
&lt;p&gt;首先说下为什么有这个话题呢，因为博主前一段时间在找工作，也算有些小心得。不过今天的重点不是那些面试题们，而是由面试想到的一些东西想跟大家分享一下，个人认为这些甚至比面试题和面试技巧要来的重要。因为这些Tips会使我们跑的更快，走的更远。当然，不分享面试题似乎又有些耍流氓的嫌疑，所以想看面试题的童鞋&lt;a href=&quot;https://github.com/PleaseCallMeCoder/Topia/tree/master/startInterview&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;戳这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里插播一下最近的行情，最近不管大道还是小道消息都透露出一个意思：行情不太好。博主是去年毕业的，非211，985的普通本科生一枚。大家应该也都知道毕业一年这个点是很尴尬的，略微有点高不成低不就的意思。那么如果你的经验不多，又没有其他闪光点的话，可能面试通知会非常的是少。那怎么让面试机会多起来呢，这个没啥捷径，努力让自己变得更牛逼吧。关于这点推荐看下任玉刚大大的：&lt;a href=&quot;http://blog.csdn.net/singwhatiwanna/article/details/19174597&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt; 树立个人品牌：让名企hr们主动来找你 &lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面我来分享一些我从面试想到的点，这些点不分先后，但都是个人感触比较深的。&lt;/p&gt;
&lt;p&gt;#我们应该会什么&lt;/p&gt;
&lt;p&gt;不止是面试，以下这些点和我们的工作也是密切相关的，研究透了一劳永逸。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java从基础到高深&lt;/li&gt;
&lt;li&gt;Android从基础到高深&lt;/li&gt;
&lt;li&gt;&lt;p&gt;数据结构和算法&lt;/p&gt;
&lt;p&gt;  关于算法我想多说几句，可能大家（包括我）会觉得这个东西有卵用，用的又不多。确实是这样的，这里给大家举个不太恰当的例子，国家为什么会征兵，和平时期又不打仗？但是不打仗我们就不征兵了么，养兵千日，用在一时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;li&gt;Android源码&lt;/li&gt;
&lt;li&gt;框架源码&lt;/li&gt;
&lt;li&gt;架构&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些点面试基本都会问道，具体问题就看面试官喜好和侧重点了。同时我们也不是为了面试而学习的，这些都会了我们的“天花板”才会更高。&lt;/p&gt;
&lt;p&gt;#把面试当作一种检验&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哪怕你不打算跳槽，隔一年左右也该整理下简历。&lt;/strong&gt;通过整理我们才能更好的把握我们在过去的一段时间是在往前跑、原地踏步还是往后退，以及我们之后该怎样做。&lt;strong&gt;隔一年左右出去面面试也是很有必要的&lt;/strong&gt;，通过面试我们可以清醒的认识到自己和自己想要的高端职位之间的距离还有多远，以及我们哪些方面还有不足。&lt;/p&gt;
&lt;p&gt;#提高核心竞争力&lt;/p&gt;
&lt;p&gt;说直白点就是我们身上有哪些点是高于这个经验段的平均的水平的，这样的点越多，我们的价值就越大。不要说我这人学东西比较快，我分析问题解决问题的能力比较强，这些套路说出来没什么杀伤力，看不到摸不着，谁知道是真是假。比如如果你有一年经验，跟其他一年经验的人一样，开源小能手一枚，细节不会比别人处理的好，同一个点也并不比别人研究的深，那人家为什么选你呢。所以&lt;strong&gt;尽量让自己有一门甚至更多拿得出手的东西&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;#我们应该如何去学习&lt;/p&gt;
&lt;p&gt;关于如何学习一些知识点，大家可以尝试下下面的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;这个东西是什么，它有什么优点，我们怎样去使用它&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;这个东西是如何实现的，为什么它会有上述的优点，我们可不可以把这种实现方式应用到其他的场景&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;我们有没有更好的实现方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如Android中的Handler机制，我们最开始肯定是先了解它是为了解决什么问题：实现子线程与UI线程的通信。Handler的基本用法是怎样的。这是第一步。其实好多人可能只到了这一步就没有再继续往下研究了。&lt;/p&gt;
&lt;p&gt;然后我们可以就可以去研究它的实现原理了，包括Handler、Message Queue、Looper。从而了解它是如何实现通信的。&lt;/p&gt;
&lt;p&gt;接下来就是发散思维了，比如我们的网络请求中会有好多请求，我们可以不以像Message Queue那样去管理我们的请求队列，能的话要怎么实现。然后我们能不能想到更好的实现线程间通信的方式。&lt;strong&gt;善于思考总结的人成就总不会太差。&lt;/strong&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;由面试想到的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="方法论" scheme="http://yoursite.com/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="方法论" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>分享一个基于MVP+Retrofit+RxJava+MaterialDesign的App</title>
    <link href="http://yoursite.com/2016/07/12/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8EMVP+Retrofit+RxJava+MaterialDesign%E7%9A%84App/"/>
    <id>http://yoursite.com/2016/07/12/分享一个基于MVP+Retrofit+RxJava+MaterialDesign的App/</id>
    <published>2016-07-12T07:59:00.000Z</published>
    <updated>2016-07-12T08:41:20.524Z</updated>
    
    <content type="html">&lt;p&gt;最近一直在忙项目的事，所以很久不写博客了。抽时间整理了下最近的收藏的一些文章，感觉新的知识点还是挺多的，于是乎自己抽时间写了一个简单的App。这个App基于MVP+Retrofit+RxJava+MaterialDesign，分享给大家。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/JgQm7Ac.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;2016已经荒废了一半，还有一半可以继续浪费。&lt;/p&gt;
&lt;p&gt;源码我已经上传到github上了，欢迎fork和star&lt;br&gt;&lt;a href=&quot;https://github.com/PleaseCallMeCoder/PrettyGirls&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/PleaseCallMeCoder/PrettyGirls&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#我想说的&lt;/p&gt;
&lt;p&gt;最近一直在忙项目的事，所以很久不写博客了。抽时间整理了下最近的收藏的一些文章，感觉新的知识点还是挺多的，于是乎自己抽时间写了一个简单的App。为什么说它简单呢？因为这个app只有四个页面而已。有人说了，这么简单你还写？答曰：麻雀虽小，五脏俱全。这个App基本包含了开发一个项目用到的所有元素。写这个app的目的如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将rxjava、retrofit、mvp、materialdesign等知识点做一个简单的整合&lt;/li&gt;
&lt;li&gt;封装一个通用baselibrary，方便以后构建项目，而且可以不断完善这个library&lt;/li&gt;
&lt;li&gt;不断优化，不断重构，因为模块少所以重构起来比较方便&lt;/li&gt;
&lt;li&gt;抛砖引玉，三人行必有我师，希望大家多多指教&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#你想知道的&lt;/p&gt;
&lt;p&gt;说完了我想说的，说说大家可能想知道的。&lt;/p&gt;
&lt;p&gt;一个项目的完整流程如下：&lt;strong&gt;痛点–&amp;gt;分析–&amp;gt;原型–&amp;gt;UI/UE–&amp;gt;设计–&amp;gt;架构–&amp;gt;测试–&amp;gt;构建–&amp;gt;QA–&amp;gt;运营–&amp;gt;迭代&lt;/strong&gt;。这里我们重点关注架构，并不是因为架构最重要，而是因为本文的重点是这个App的整体架构。&lt;/p&gt;
&lt;p&gt;##项目结构&lt;/p&gt;
&lt;p&gt;这里我用了&lt;strong&gt;MVP模式配合多模块Activty+多Fragment&lt;/strong&gt;的思路。对于MVP和Fragment的有点这里我就不过多介绍了。我简单说下我的实现思路。&lt;/p&gt;
&lt;p&gt;###封装一个baselibrary&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以利用以往项目经验分模块分类别封装出一些父类，完成公共操作，后续开发只需要继承这些父类就可以完成大部分操作，节省开发成本。&lt;/strong&gt;这里我封装了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包括普通activity和支持右滑退出当前页面的activity父类（退出方式类似qq）&lt;/li&gt;
&lt;li&gt;activity管理栈&lt;/li&gt;
&lt;li&gt;fragment的基类&lt;/li&gt;
&lt;li&gt;adapter的基类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个library基本已经满足了这个App的开发。但是没有最好只有更好，这个baselibrary我会不断完善和优化，以满足更复杂的需求。&lt;/p&gt;
&lt;p&gt;###分包&lt;/p&gt;
&lt;p&gt;这里我采用的是&lt;strong&gt;按模块来划分包&lt;/strong&gt;。包括以下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;app&lt;/p&gt;
&lt;p&gt;  包括全局异常处理，系统常量，和app的基本配置等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;模块包&lt;/p&gt;
&lt;p&gt;  每个模块包含一个契约接口，本模块的一个activity和多个fragment，presenter的实现类等，当然如果模块比较复杂还可以再继续分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;data&lt;/p&gt;
&lt;p&gt;  提供app的本地或者远程数据，数据模型等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;util&lt;/p&gt;
&lt;p&gt;  工具类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;widget&lt;/p&gt;
&lt;p&gt;  自定义控件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##依赖库&lt;/p&gt;
&lt;p&gt;至于依赖库的选择个人认为因人而异，我使用的库如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://jakewharton.github.io/butterknife/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;butterknife&lt;/a&gt;————View注解库和配套插件&lt;a href=&quot;https://github.com/avast/android-butterknife-zelezny&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;android-butterknife-zelezny&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/square/retrofit&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;retrofit&lt;/a&gt;+&lt;a href=&quot;https://github.com/square/okhttp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;okhttp&lt;/a&gt;————网络请求相关&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/google/gson&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;gson&lt;/a&gt;————google推荐的json数据解析库&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bumptech/glide&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;glide&lt;/a&gt;————google推荐的Android图片加载库&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxAndroid&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RxAndroid&lt;/a&gt;+&lt;a href=&quot;https://github.com/ReactiveX/RxJava/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RxJava&lt;/a&gt;——Rx函数响应式编程&lt;a href=&quot;https://mcxiaoke.gitbooks.io/rxdocs/content/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中文文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;compile ‘com.android.support:design:23.0.1’————谷歌Material Design控件库&lt;/p&gt;
&lt;p&gt;#关于App&lt;/p&gt;
&lt;p&gt;app截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/T9U8g5b.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/ivGy3ga.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/HI3PipV.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/PleaseCallMeCoder/PrettyGirls&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://pre.im/A7n1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#鸣谢&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gank.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;代码家-干货集中营&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/oxoooo/mr-mantou-android&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;OXO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;所有开源的人&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#结语&lt;/p&gt;
&lt;p&gt;关注博主是一种态度，评论博主是一种欣赏！！&lt;/p&gt;
&lt;p&gt;最后，欢迎大家关注我的微信公众号：CoderTopia。&lt;/p&gt;
&lt;center&gt;&lt;img style=&quot;width:150px; height:150px&quot; src=&quot;http://img.blog.csdn.net/20160422143030784&quot;&gt;&lt;/center&gt;


</content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直在忙项目的事，所以很久不写博客了。抽时间整理了下最近的收藏的一些文章，感觉新的知识点还是挺多的，于是乎自己抽时间写了一个简单的App。这个App基于MVP+Retrofit+RxJava+MaterialDesign，分享给大家。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="APP" scheme="http://yoursite.com/categories/APP/"/>
    
    
      <category term="MaterialDesign" scheme="http://yoursite.com/tags/MaterialDesign/"/>
    
      <category term="APP" scheme="http://yoursite.com/tags/APP/"/>
    
      <category term="MVP" scheme="http://yoursite.com/tags/MVP/"/>
    
      <category term="Retrofit" scheme="http://yoursite.com/tags/Retrofit/"/>
    
      <category term="RxJava" scheme="http://yoursite.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Andorid网络操作和优化相关</title>
    <link href="http://yoursite.com/2016/06/12/Android%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C%E5%92%8C%E4%BC%98%E5%8C%96%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2016/06/12/Android网络操作和优化相关/</id>
    <published>2016-06-12T04:43:00.000Z</published>
    <updated>2016-06-14T02:36:13.506Z</updated>
    
    <content type="html">&lt;p&gt;Andorid网络操作相关和优化关键点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/CKaD46w.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;人性的弱点在于习惯于学习精确的东西而不善于总体的把握。&lt;/p&gt;
&lt;p&gt;#写在前面的话&lt;/p&gt;
&lt;p&gt;Android程序最重要的模块就是网络部分，如何从网络上下载数据，如何将处理过的数据上传至网络，往往是android程序的关键环节。前几天偶一朋友遇到这么一个问题：如何使用volley实现文件上传。最后问题解决了，小伙伴不禁有些飘飘然，大有一番天下之事皆逃不过我的魔掌的感觉。这时候coder君问了他几个问题，大家可以一起思考下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP/IP协议、SOCKET、HTTP协议、HTTPS协议都是做什么的，他们之间有关系吗&lt;/li&gt;
&lt;li&gt;你是如何管理网络使用情况的&lt;/li&gt;
&lt;li&gt;常用的HTTP Client有哪些，该如何选择&lt;/li&gt;
&lt;li&gt;假如你需要修改的你网络请求框架，你要动多少代码&lt;/li&gt;
&lt;li&gt;你是怎么进行网络优化的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;小伙伴支支吾吾，其实他熟悉的只是Android中网络相关的那些点中的一小部分，不免有些盲人摸象的感觉，你呢？&lt;/p&gt;
&lt;p&gt;#网络通信机制&lt;/p&gt;
&lt;p&gt;网络由下往上分为：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。&lt;/p&gt;
&lt;p&gt;IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层，三者从本质上来说没有可比性，socket则是对TCP/IP协议的封装和应用。也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。&lt;/p&gt;
&lt;p&gt;##TCP/IP协议&lt;/p&gt;
&lt;p&gt;网络编程的目的就是直接或间接地通过网络协议与其他计算机进行通讯。&lt;/p&gt;
&lt;p&gt;网络编程中有两个主要的问题，一个是如何准确的定位网络上一台或多台主机；另一个就是找到主机后如何可靠高效的进行数据传输。目前使用最广泛的因特网协议是TCP/IP协议。&lt;/p&gt;
&lt;p&gt;在TCP/IP协议中IP层主要负责网络主机的定位，数据传输的路由，由IP地址可以唯一地确定Internet上的一台主机。而TCP层则提供面向应用的可靠的或非可靠的数据传输机制，这是网络编程的主要对象，一般不需要关心IP层是如何处理数据的。&lt;/p&gt;
&lt;p&gt;##Socket&lt;/p&gt;
&lt;p&gt;我们知道两个进程如果需要进行通讯最基本的一个前提能能够唯一的标示一个进程，在本地进程通讯中我们可以使用PID来唯一标示一个进程，但PID只在本地唯一，网络中的两个进程PID冲突几率很大，这时候我们需要另辟它径了，我们知道IP层的ip地址可以唯一标示主机，而TCP层协议和端口号可以唯一标示主机的一个进程，这样我们可以利用ip地址＋协议＋端口号唯一标示网络中的一个进程。&lt;/p&gt;
&lt;p&gt;能够唯一标示网络中的进程后，它们就可以利用socket进行通信了，什么是socket呢？我们经常把socket翻译为套接字，socket是在应用层和传输层之间的一个抽象层，它把TCP/IP层复杂的操作抽象为几个简单的接口供应用层调用已实现进程在网络中通信。&lt;/p&gt;
&lt;p&gt;Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，&lt;/p&gt;
&lt;p&gt;##Http协议&lt;/p&gt;
&lt;p&gt;HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。&lt;/p&gt;
&lt;p&gt;HTTP连接最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。&lt;/p&gt;
&lt;p&gt;HTTP提供了封装或者显示数据的具体形式。Socket提供了网络通信的能力。&lt;/p&gt;
&lt;p&gt;##Https协议&lt;/p&gt;
&lt;p&gt;HTTPS（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。被广泛用于万维网上安全敏感的通讯，例如交易支付方面。&lt;/p&gt;
&lt;p&gt;#Android网络权限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;uses-permission android:name=&amp;quot;android.permission.INTERNET&amp;quot; /&amp;gt;&amp;lt;-- 允许应用程序打开网络套接字 --&amp;gt;
&amp;lt;uses-permission android:name=&amp;quot;android.permission.ACCESS_NETWORK_STATE&amp;quot; /&amp;gt;&amp;lt;-- 允许应用程序访问网络连接信息 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#选择一个HTTP Client&lt;/p&gt;
&lt;p&gt;大多数连接网络的 Android app 会使用 HTTP 来发送与接收数据。Android 提供了三种 HTTP client：HttpURLConnection、Apache HttpClient和okhttp。二者均支持 HTTPS、流媒体上传和下载、可配置的超时、IPv6 与连接池（connection pooling）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Java.net包中的HttpURLConnection类 &lt;/p&gt;
&lt;p&gt;  HttpUrlConnection是JDK里提供的联网API，我们知道Android SDK是基于Java的，所以当然优先考虑HttpUrlConnection这种最原始最基本的API，其实大多数开源的联网框架基本上也是基于JDK的HttpUrlConnection进行的封装罢了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HttpClient&lt;/p&gt;
&lt;p&gt;  HttpClient是开源组织Apache提供的Java请求网络框架，其最早是为了方便Java服务器开发而诞生的，是对JDK中的HttpUrlConnection各API进行了封装和简化，提高了性能并且降低了调用API的繁琐，Android因此也引进了这个联网框架，我们再不需要导入任何jar或者类库就可以直接使用，值得注意的是Android官方已经宣布不建议使用HttpClient了，我们再开发的时候尽量少用吧，但是用了也无妨！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;okhttp&lt;/p&gt;
&lt;p&gt;  http是现在主流应用使用的网络请求方式, 用来交换数据和内容, 有效的使用HTTP可以使你的APP变的更快和减少流量的使用。&lt;/p&gt;
&lt;p&gt;  OkHttp是一个很棒HTTP客户端:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持SPDY,可以合并多个到同一个主机的请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;- 使用连接池技术减少请求的延迟(如果SPDY是可用的话)


- 使用GZIP压缩减少传输的数据量


- 缓存响应避免重复的网络请求

当你的网络出现拥挤的时候,就是OKHttp大显身手的时候,它可以避免常见的网络问题,如果你的服务是部署在不同的IP上面的,如果第一个连接失败,OkHTtp会尝试其他的连接。这对现在IPv4+IPv6中常见的把服务冗余部署在不同的数据中心上也是很有必要的。OkHttp将使用现在TLS特性(SNI ALPN)来初始化新的连接，如果握手失败,将切换到TLS 1.0。

使用OkHttp很容易,同时支持异步阻塞请求和回调.

如果你使用OkHttp ,你不用重写你的代码,   okhttp-urlconnection模块实现了 java.net.HttpURLConnection 中的API,  okhttp-apache模块实现了HttpClient中的API
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;#如何管理网络的使用情况&lt;/p&gt;
&lt;p&gt;如果我们的程序需要执行大量网络操作，那么应该提供用户设置选项，来允许用户控制程序的数据偏好。例如，同步数据的频率，是否只在连接到 WiFi 才进行下载与上传操作，是否在漫游时使用套餐数据流量等等。这样用户才不大可能在快到达流量上限时，禁止我们的程序获取后台数据，因为他们可以精确控制我们的 app 使用多少数据流量。&lt;/p&gt;
&lt;p&gt;##检查网络连接&lt;/p&gt;
&lt;p&gt;在执行网络操作之前，检查设备当前连接的网络连接信息是个好习惯。这样可以防止我们的程序在无意间连接使用了非意向的网络频道。如果网络连接不可用，那么我们的应用应该优雅地做出响应。为了检测网络连接，我们需要使用到下面两个类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;ConnectivityManager：它会回答关于网络连接的查询结果，并在网络连接改变时通知应用程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NetworkInfo：描述一个给定类型（移动网络或 Wi-Fi等）的网络接口状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面这个方法可以找到的第一个已连接的网络接口，如果返回null，则表示没有已连接的网络接口(意味着网络连接不可用)：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean isOnline() {
    ConnectivityManager connMgr = (ConnectivityManager)getSystemServic(Context.CONNECTIVITY_SERVICE);
    NetworkInfo networkInfo = connMgr.getActiveNetworkInfo();
    return (networkInfo != null &amp;amp;&amp;amp; networkInfo.isConnected());
} 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##管理网络的使用情况&lt;/p&gt;
&lt;p&gt;我们可以实现一个偏好设置的选项，使用户能直接设置程序对网络资源的使用情况。例如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以允许用户仅在连接到 Wi-Fi 时上传视频。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;可以根据诸如网络可用，时间间隔等条件来选择是否做同步的操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##检测网络连接变化&lt;/p&gt;
&lt;p&gt;要检测网络连接的变化需要用到BroadcastReceiver 的子类：NetworkReceiver。当设备网络连接改变时，NetworkReceiver 会监听到 CONNECTIVITY_ACTION，这时需要判断当前网络连接类型并相应的设置好 wifiConnected 与 mobileConnected。&lt;/p&gt;
&lt;p&gt;这里需要注意的是在使用BroadcastReceiver的时候，不必要的声明注册会浪费系统资源。最好在 onCreate()中注册 BroadcastReceiver NetworkReceiver，在 onDestroy()中销毁它。这样做会比在 manifest 里面声明 &lt;receiver&gt; 更轻巧。&lt;/receiver&gt;&lt;/p&gt;
&lt;p&gt;#在一个单独的线程中执行网络操作&lt;/p&gt;
&lt;p&gt;网络操作会遇到不可预期的延迟。为了避免造成不好的用户体验，确保总是在 UI 线程之外单独的线程中执行网络操作。关于Android中的线程和进程可以参考&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/51556041&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;#封装网络请求&lt;/p&gt;
&lt;p&gt;有了Http Client，我们需要考虑的是如何优雅的使用这些Http Client进行网络请求。这时候我们可以对Http Clent进行封装来满足我们的需求。封装的基本要点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持自定义请求的Header&lt;/li&gt;
&lt;li&gt;支持Http的基本请求方法：GET、POST、PUT、DELETE等&lt;/li&gt;
&lt;li&gt;支持文件上传和下载&lt;/li&gt;
&lt;li&gt;可以加载图片&lt;/li&gt;
&lt;li&gt;支持多任务网络请求操作&lt;/li&gt;
&lt;li&gt;支持缓存&lt;/li&gt;
&lt;li&gt;支持请求回调&lt;/li&gt;
&lt;li&gt;支持session的保持&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体可以参考&lt;a href=&quot;http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Volley源码分析&lt;/a&gt;、&lt;a href=&quot;http://www.jianshu.com/p/45cb536be2f4&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Retrofit分析&lt;/a&gt;等，看看这些成名已久的框架是如何封装的。&lt;/p&gt;
&lt;p&gt;#网络请求框架&lt;/p&gt;
&lt;p&gt;以下是曾经很火或者现在很多的网络请求框架：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android Async HTTP&lt;/li&gt;
&lt;li&gt;AndroidAsync&lt;/li&gt;
&lt;li&gt;Volley&lt;/li&gt;
&lt;li&gt;Retrofit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AsyncHttp是一个较高层的封装，底层使用的是HttpClient。&lt;/p&gt;
&lt;p&gt;Volley是Google推出的Android异步网络请求框架和图片加载框架。底层网络请求可以使用不同的网络库来处理，比如OkHttp，HttpClient。&lt;/p&gt;
&lt;p&gt;Retrofit是一个封装比较好的，相对更面向开发者的rest请求库，它的底层网络请求也可以使用不同的网络库来处理。&lt;/p&gt;
&lt;p&gt;#网络请求框架再封装&lt;/p&gt;
&lt;p&gt;我在&lt;a href=&quot;http://blog.csdn.net/sdkfjksf/article/details/51106335&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这些Tips让你的App更容易维护 &lt;/a&gt;简单提到过面向接口编程，这对于网络框架再封装很实用。&lt;/p&gt;
&lt;p&gt;我们可以定义一套我们自己的网络请求接口，接口规定我们需要有什么能力的框架。调用的话我们可以直接调用接口方法就好了，这样不管我们换什么网络框架，只要这个框架有网络请求的能力就行。举个例子，定义接口如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface ISender {

    void send(METHOD method, String url, SenderCallback callback);

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们写一个类实现这个接口：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class BaseSender implements ISender {
    @Override
    public synchronized void sender(METHOD method, final String url, final SenderCallback callback) {
        //volley,retrofit,balabala,用任意网络请求框架实现。

    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后是我们的SendCallback&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public interface SendCallback {

    //请求成功回调
    void onSucceeed(String t);

    //请求失败回调
    void onError(String errorMsg);

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后是我们的调用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private ISender mHttp;

public void getWeahter(String tag) {

    //调用接口里定义好的方法
    mHttp.sender();

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里传入我们需要的参数就好了。&lt;/p&gt;
&lt;p&gt;#数据解析&lt;/p&gt;
&lt;p&gt;以下是比较流行的网络数据解析的库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Gson&lt;/li&gt;
&lt;li&gt;Jackson&lt;/li&gt;
&lt;li&gt;FastJson&lt;/li&gt;
&lt;li&gt;HtmlPaser&lt;/li&gt;
&lt;li&gt;Jsoup&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络数据解析比较基础，这里就不过多描述了。&lt;/p&gt;
&lt;p&gt;#移动端网络优化&lt;br&gt;对于手机程序，网络操作相对来说是比较耗电的行为。优化网络操作能够显著节约电量的消耗。一个网络请求可以简单分为&lt;strong&gt;连接服务器&lt;/strong&gt;和&lt;strong&gt;获取数据&lt;/strong&gt;两个部分。其中连接服务器前还包括 DNS 解析的过程；获取数据后可能会对数据进行缓存。那么我们如果要进行网络优化需要从这两个关键点入手。&lt;/p&gt;
&lt;p&gt;以下是具体可以优化的点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不用域名，用IP直连&lt;/p&gt;
&lt;p&gt;  省去 DNS 解析过程，DNS 全名 Domain Name System，解析意指根据域名得到其对应的IP地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器合理部署&lt;/p&gt;
&lt;p&gt;  服务器多运营商多地部署，一般至少含三大运营商、南中北三地部署。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;根据当前的网络环境选择当下最佳的策略&lt;/p&gt;
&lt;p&gt;  主要的实施步骤有两步：第1是检测收集当前的网络环境信息，第2是根据当前收集到的信息进行网络请求行为的调整。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;预取&lt;/p&gt;
&lt;p&gt;  我们需要预先判断用户在此次操作之后，后续零散的请求是否很有可能会马上被触发，可以把后面几分钟有可能会使用到的零散请求都一次集中执行完毕。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;连接复用&lt;/p&gt;
&lt;p&gt;  节省连接建立时间，如开启 keep-alive。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;用捆绑批量访问的方式来减少访问的频率&lt;/p&gt;
&lt;p&gt;  预先判定那些可能马上就会使用到的网络资源，捆绑一起集中进行网络请求。这点我们可以考虑按照提前预期后续1-2分钟的数据作为基准。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;分优先级、延迟部分请求&lt;/p&gt;
&lt;p&gt; 首先我们需要区分哪些网络请求是需要及时返回结果的，哪些是可以延迟执行的。我们可以有针对性的把请求行为捆绑起来，延迟到某个时刻统一发起请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对传输的数据进行压缩&lt;/p&gt;
&lt;p&gt;  网络传输数据量的大小主要由两部分组成：图片与序列化的数据，那么我们需要做的就是减少这两部分的数据传输大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;多连接&lt;/p&gt;
&lt;p&gt;  对于较大文件，如大图片、文件下载可考虑多连接。 需要控制请求的最大并发量，毕竟移动端网络受限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免不必要的同步操作&lt;/p&gt;
&lt;p&gt;  应用程序的一个基础功能是能够保持确保界面上呈现的信息是即时最新的，例如呈现最新的新闻，天气，信息流等等信息。但是，过于频繁的促使手机客户端应用去同步最新的服务器数据会对性能产生很大的负面影响，不仅仅使得CPU不停的在工作，内存，网络流量，电量等等都会持续的被消耗，所以在进行网络请求操作的时候一定要避免多度同步操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;做好网络数据的缓存&lt;/p&gt;
&lt;p&gt;  从手机的缓存中直接读取数据肯定比从网络上获取数据要更加的便捷高效，特别是对于那些会被频繁访问到的数据，需要把这些数据缓存到设备上，以便更加快速的进行访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#结语&lt;/p&gt;
&lt;p&gt;关注博主是一种态度，评论博主是一种欣赏！！&lt;/p&gt;
&lt;p&gt;最后，欢迎大家关注我的微信公众号：CoderTopia。&lt;/p&gt;
&lt;center&gt;&lt;img style=&quot;width:150px; height:150px&quot; src=&quot;http://img.blog.csdn.net/20160422143030784&quot;&gt;&lt;/center&gt;


&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.trinea.cn/android/mobile-performance-optimization/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.trinea.cn/android/mobile-performance-optimization/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hukai.me/android-performance-patterns-season-4/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hukai.me/android-performance-patterns-season-4/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hukai.me/android-performance-patterns-season-2/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://hukai.me/android-performance-patterns-season-2/&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Andorid网络操作相关和优化关键点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="Andorid中的网络操作" scheme="http://yoursite.com/tags/Andorid%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C/"/>
    
      <category term="移动端网络优化" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E7%BB%9C%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Andorid中的进程和线程</title>
    <link href="http://yoursite.com/2016/06/01/Android%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/06/01/Android中的进程和线程/</id>
    <published>2016-06-01T07:00:00.000Z</published>
    <updated>2016-06-14T02:36:32.741Z</updated>
    
    <content type="html">&lt;p&gt;Andorid进程和线程相关概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#写在前面的话&lt;/p&gt;
&lt;p&gt;个Android应用就是一个Linux进程，每个应用在各自的进程中运行，互不干扰，比较安全。&lt;/p&gt;
&lt;p&gt;一个应用对应一个主线程，就是通常所说的UI线程，android遵守的就是单线程模型，所以说Ui操作不是线程安全的并且这些操作必须在UI线程中执行。&lt;/p&gt;
&lt;p&gt;本文是对官方文档的翻译，原文链接：&lt;a href=&quot;https://developer.android.com/guide/components/processes-and-threads.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://developer.android.com/guide/components/processes-and-threads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;#概述&lt;/p&gt;
&lt;p&gt;当某个应用组件启动且该应用没有运行其他任何组件时，Android 系统会使用单个执行线程为应用启动新的 Linux 进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。 如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。 但是，您可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。&lt;/p&gt;
&lt;p&gt;本文档介绍进程和线程在 Android 应用中的工作方式。&lt;/p&gt;
&lt;p&gt;#进程&lt;/p&gt;
&lt;p&gt;默认情况下，同一应用的所有组件均在相同的进程中运行，且大多数应用都不会改变这一点。 但是，如果您发现需要控制某个组件所属的进程，则可在清单文件中执行此操作。&lt;/p&gt;
&lt;p&gt;各类组件元素的清单文件条目—&lt;activity&gt;、&lt;service&gt;、&lt;receiver&gt; 和 &lt;provider&gt;—均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。您可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，您还可以设置 android:process，使不同应用的组件在相同的进程中运行，但前提是这些应用共享相同的 Linux 用户 ID 并使用相同的证书进行签署。&lt;/provider&gt;&lt;/receiver&gt;&lt;/service&gt;&lt;/activity&gt;&lt;/p&gt;
&lt;p&gt;此外，&lt;application&gt; 元素还支持 android:process 属性，以设置适用于所有组件的默认值。&lt;/application&gt;&lt;/p&gt;
&lt;p&gt;如果内存不足，而其他为用户提供更紧急服务的进程又需要内存时，Android 可能会决定在某一时刻关闭某一进程。在被终止进程中运行的应用组件也会随之销毁。 当这些组件需要再次运行时，系统将为它们重启进程。&lt;/p&gt;
&lt;p&gt;决定终止哪个进程时，Android 系统将权衡它们对用户的相对重要程度。例如，相对于托管可见 Activity 的进程而言，它更有可能关闭托管屏幕上不再可见的 Activity 进程。 因此，是否终止某个进程的决定取决于该进程中所运行组件的状态。 下面，我们介绍决定终止进程所用的规则。&lt;/p&gt;
&lt;p&gt;##进程生命周期&lt;/p&gt;
&lt;p&gt;Android 系统将尽量长时间地保持应用进程，但为了新建进程或运行更重要的进程，最终需要清除旧进程来回收内存。 为了确定保留或终止哪些进程，系统会根据进程中正在运行的组件以及这些组件的状态，将每个进程放入“重要性层次结构”中。 必要时，系统会首先消除重要性最低的进程，然后是重要性略逊的进程，依此类推，以回收系统资源。&lt;/p&gt;
&lt;p&gt;重要性层次结构一共有 5 级。以下列表按照重要程度列出了各类进程（第一个进程最重要，将是最后一个被终止的进程）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;前台进程&lt;/p&gt;
&lt;p&gt; 用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;- 托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）
- 托管某个 Service，后者绑定到用户正在交互的 Activity
- 托管正在“前台”运行的 Service（服务已调用 startForeground()）
- 托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）
- 托管正执行其 onReceive() 方法的 BroadcastReceiver

通常，在任意给定时间前台进程都为数不多。只有在内在不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;可见进程&lt;/p&gt;
&lt;p&gt; 没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况&lt;/li&gt;
&lt;li&gt;&lt;p&gt;托管绑定到可见（或前台）Activity 的 Service&lt;/p&gt;
&lt;p&gt;可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务进程&lt;/p&gt;
&lt;p&gt; 正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;后台进程&lt;/p&gt;
&lt;p&gt; 包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。 有关保存和恢复状态的信息，请参阅Activity文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;空进程&lt;/p&gt;
&lt;p&gt; 不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据进程中当前活动组件的重要程度，Android 会将进程评定为它可能达到的最高级别。例如，如果某进程托管着服务和可见 Activity，则会将此进程评定为可见进程，而不是服务进程。&lt;/p&gt;
&lt;p&gt;此外，一个进程的级别可能会因其他进程对它的依赖而有所提高，即服务于另一进程的进程其级别永远不会低于其所服务的进程。 例如，如果进程 A 中的内容提供程序为进程 B 中的客户端提供服务，或者如果进程 A 中的服务绑定到进程 B 中的组件，则进程 A 始终被视为至少与进程 B 同样重要。&lt;/p&gt;
&lt;p&gt;由于运行服务的进程其级别高于托管后台 Activity 的进程，因此启动长时间运行操作的 Activity 最好为该操作启动服务，而不是简单地创建工作线程，当操作有可能比 Activity 更加持久时尤要如此。例如，正在将图片上传到网站的 Activity 应该启动服务来执行上传，这样一来，即使用户退出 Activity，仍可在后台继续执行上传操作。使用服务可以保证，无论 Activity 发生什么情况，该操作至少具备“服务进程”优先级。 同理，广播接收器也应使用服务，而不是简单地将耗时冗长的操作放入线程中。&lt;/p&gt;
&lt;p&gt;#线程&lt;/p&gt;
&lt;p&gt;应用启动时，系统会为应用创建一个名为“主线程”的执行线程。 此线程非常重要，因为它负责将事件分派给相应的用户界面小工具，其中包括绘图事件。 此外，它也是应用与 Android UI 工具包组件（来自 android.widget 和 android.view 软件包的组件）进行交互的线程。因此，主线程有时也称为 UI 线程。&lt;/p&gt;
&lt;p&gt;系统绝对不会为每个组件实例创建单独的线程。运行于同一进程的所有组件均在 UI 线程中实例化，并且对每个组件的系统调用均由该线程进行分派。因此，响应系统回调的方法（例如，报告用户操作的 onKeyDown() 或生命周期回调方法）始终在进程的 UI 线程中运行。&lt;/p&gt;
&lt;p&gt;例如，当用户触摸屏幕上的按钮时，应用的 UI 线程会将触摸事件分派给小工具，而小工具反过来又设置其按下状态，并将无效请求发布到事件队列中。UI 线程从队列中取消该请求并通知小工具应该重绘自身。&lt;/p&gt;
&lt;p&gt;在应用执行繁重的任务以响应用户交互时，除非正确实施应用，否则这种单线程模式可能会导致性能低下。 特别地，如果 UI 线程需要处理所有任务，则执行耗时很长的操作（例如，网络访问或数据库查询）将会阻塞整个 UI。一旦线程被阻塞，将无法分派任何事件，包括绘图事件。从用户的角度来看，应用显示为挂起。 更糟糕的是，如果 UI 线程被阻塞超过几秒钟时间（目前大约是 5 秒钟），用户就会看到一个让人厌烦的“应用无响应”(ANR) 对话框。如果引起用户不满，他们可能就会决定退出并卸载此应用。&lt;/p&gt;
&lt;p&gt;此外，Android UI 工具包并非线程安全工具包。因此，您不得通过工作线程操纵 UI，而只能通过 UI 线程操纵用户界面。因此，Android 的单线程模式必须遵守两条规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不要阻塞 UI 线程&lt;/li&gt;
&lt;li&gt;不要在 UI 线程之外访问 Android UI 工具包&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;##工作线程&lt;/p&gt;
&lt;p&gt;根据上述单线程模式，要保证应用 UI 的响应能力，关键是不能阻塞 UI 线程。如果执行的操作不能很快完成，则应确保它们在单独的线程（“后台”或“工作”线程）中运行。&lt;/p&gt;
&lt;p&gt;例如，以下代码演示了一个点击侦听器从单独的线程下载图像并将其显示在 ImageView 中：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void onClick(View v) {
    new Thread(new Runnable() {
        public void run() {
            Bitmap b = loadImageFromNetwork(&amp;quot;http://example.com/image.png&amp;quot;);
            mImageView.setImageBitmap(b);
        }
    }).start();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;乍看起来，这段代码似乎运行良好，因为它创建了一个新线程来处理网络操作。 但是，它违反了单线程模式的第二条规则：不要在 UI 线程之外访问 Android UI 工具包—此示例从工作线程（而不是 UI 线程）修改了 ImageView。这可能导致出现不明确、不可预见的行为，但要跟踪此行为困难而又费时。&lt;/p&gt;
&lt;p&gt;为解决此问题，Android 提供了几种途径来从其他线程访问 UI 线程。以下列出了几种有用的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Activity.runOnUiThread(Runnable)&lt;/li&gt;
&lt;li&gt;View.post(Runnable)&lt;/li&gt;
&lt;li&gt;View.postDelayed(Runnable, long)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如，您可以通过使用 View.post(Runnable) 方法修复上述代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void onClick(View v) {
    new Thread(new Runnable() {
        public void run() {
            final Bitmap bitmap = loadImageFromNetwork(&amp;quot;http://example.com/image.png&amp;quot;);
            mImageView.post(new Runnable() {
                public void run() {
                    mImageView.setImageBitmap(bitmap);
                }
            });
        }
    }).start();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在，上述实现属于线程安全型：在单独的线程中完成网络操作，而在 UI 线程中操纵 ImageView。&lt;/p&gt;
&lt;p&gt;但是，随着操作日趋复杂，这类代码也会变得复杂且难以维护。 要通过工作线程处理更复杂的交互，可以考虑在工作线程中使用 Handler 处理来自 UI 线程的消息。当然，最好的解决方案或许是扩展 AsyncTask 类，此类简化了与 UI 进行交互所需执行的工作线程任务。&lt;/p&gt;
&lt;p&gt;###使用 AsyncTask&lt;/p&gt;
&lt;p&gt;AsyncTask 允许对用户界面执行异步操作。它会先阻塞工作线程中的操作，然后在 UI 线程中发布结果，而无需您亲自处理线程和/或处理程序。&lt;/p&gt;
&lt;p&gt;要使用它，必须创建 AsyncTask 子类并实现 doInBackground() 回调方法，该方法将在后台线程池中运行。要更新 UI，必须实现 onPostExecute() 以传递 doInBackground() 返回的结果并在 UI 线程中运行，这样，您即可安全更新 UI。稍后，您可以通过从 UI 线程调用 execute() 来运行任务。&lt;/p&gt;
&lt;p&gt;例如，您可以通过以下方式使用 AsyncTask 来实现上述示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public void onClick(View v) {
    new DownloadImageTask().execute(&amp;quot;http://example.com/image.png&amp;quot;);
}

private class DownloadImageTask extends AsyncTask&amp;lt;String, Void, Bitmap&amp;gt; {
    /** The system calls this to perform work in a worker thread and
      * delivers it the parameters given to AsyncTask.execute() */
    protected Bitmap doInBackground(String... urls) {
        return loadImageFromNetwork(urls[0]);
    }

    /** The system calls this to perform work in the UI thread and delivers
      * the result from doInBackground() */
    protected void onPostExecute(Bitmap result) {
        mImageView.setImageBitmap(result);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;现在 UI 是安全的，代码也得到简化，因为任务分解成了两部分：一部分应在工作线程内完成，另一部分应在 UI 线程内完成。&lt;/p&gt;
&lt;p&gt;下面简要概述了 AsyncTask 的工作方法，但要全面了解如何使用此类，您应阅读 AsyncTask 参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以使用泛型指定参数类型、进度值和任务最终值&lt;/li&gt;
&lt;li&gt;方法 doInBackground() 会在工作线程上自动执行&lt;/li&gt;
&lt;li&gt;onPreExecute()、onPostExecute() 和 onProgressUpdate() 均在 UI 线程中调用&lt;/li&gt;
&lt;li&gt;doInBackground() 返回的值将发送到 onPostExecute()&lt;/li&gt;
&lt;li&gt;您可以随时在 doInBackground() 中调用publishProgress()，以在 UI 线程中执行 onProgressUpdate()&lt;/li&gt;
&lt;li&gt;您可以随时取消任何线程中的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：使用工作线程时可能会遇到另一个问题，即：运行时配置变更（例如，用户更改了屏幕方向）导致 Activity 意外重启，这可能会销毁工作线程。 要了解如何在这种重启情况下坚持执行任务，以及如何在 Activity 被销毁时正确地取消任务，请参阅书架示例应用的源代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##线程安全方法&lt;/p&gt;
&lt;p&gt;在某些情况下，您实现的方法可能会从多个线程调用，因此编写这些方法时必须确保其满足线程安全的要求。&lt;/p&gt;
&lt;p&gt;这一点主要适用于可以远程调用的方法，如绑定服务中的方法。如果对 IBinder 中所实现方法的调用源自运行 IBinder 的同一进程，则该方法在调用方的线程中执行。但是，如果调用源自其他进程，则该方法将在从线程池选择的某个线程中执行（而不是在进程的 UI 线程中执行），线程池由系统在与 IBinder 相同的进程中维护。例如，即使服务的 onBind() 方法将从服务进程的 UI 线程调用，在 onBind() 返回的对象中实现的方法（例如，实现 RPC 方法的子类）仍会从线程池中的线程调用。由于一个服务可以有多个客户端，因此可能会有多个池线程在同一时间使用同一 IBinder 方法。因此，IBinder 方法必须实现为线程安全方法。&lt;/p&gt;
&lt;p&gt;同样，内容提供程序也可接收来自其他进程的数据请求。尽管 ContentResolver 和 ContentProvider 类隐藏了如何管理进程间通信的细节，但响应这些请求的 ContentProvider 方法（query()、insert()、delete()、update() 和 getType() 方法）将从内容提供程序所在进程的线程池中调用，而不是从进程的 UI 线程调用。由于这些方法可能会同时从任意数量的线程调用，因此它们也必须实现为线程安全方法。&lt;/p&gt;
&lt;p&gt;#进程间通信&lt;/p&gt;
&lt;p&gt;Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity 或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。 然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此您只需集中精力定义和实现 RPC 编程接口即可。&lt;/p&gt;
&lt;p&gt;要执行 IPC，必须使用 bindService() 将应用绑定到服务上。如需了解详细信息，请参阅服务开发者指南。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Andorid进程和线程相关概念。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="多线程" scheme="http://yoursite.com/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="Andorid中的进程和线程" scheme="http://yoursite.com/tags/Andorid%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="AsyncTask" scheme="http://yoursite.com/tags/AsyncTask/"/>
    
  </entry>
  
  <entry>
    <title>方法论-成为大神路上的捷径</title>
    <link href="http://yoursite.com/2016/05/17/%E6%96%B9%E6%B3%95%E8%AE%BA-%E6%88%90%E4%B8%BA%E5%A4%A7%E7%A5%9E%E8%B7%AF%E4%B8%8A%E7%9A%84%E6%8D%B7%E5%BE%84/"/>
    <id>http://yoursite.com/2016/05/17/方法论-成为大神路上的捷径/</id>
    <published>2016-05-17T01:21:00.000Z</published>
    <updated>2016-09-06T06:28:40.936Z</updated>
    
    <content type="html">&lt;p&gt;跟大家分享一下成为大神路上的捷径，与诸君共勉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/PxCfAEr.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个人都在成为大神的路上，只不过有的人在走，而有的人在跑。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#写在前面的话&lt;/p&gt;
&lt;p&gt;在开始正文之前我先跟大家分享一个我身边的例子。我有两个朋友，A和B。B从高一开始打dota，A从高二开始，到高中毕业的时候，A已经是一个2100分的大神级别的人物，而B只有1200分而已。为什么A打的时间比B短，而水平却比B高呢？是天赋？是智商？似乎都不是。&lt;/p&gt;
&lt;p&gt;我对两个人还是比较了解的，虽然同样是打dota，但是A和B之间有着很大差别的。A除了像B一样打dota之外，会看一些成名已久的大神的教学视频，会看自己打dota的录像然后反思，会逛贴吧学习一些新的打法以及连招，会不断练习自己做得不好的地方。然后A成了大神，而B依然是一只菜鸟。&lt;/p&gt;
&lt;p&gt;其实成为大神的路上，真的有一些捷径，不论是打dota、销售，还是开发。&lt;/p&gt;
&lt;p&gt;#自我定位以及目标&lt;/p&gt;
&lt;p&gt;“我是蒙奇·D·路飞，要成为海贼王的男人。”草帽同学的这句话既霸气又充满哲理。假如现在的你是一个小菜鸟，但你想要成为宇宙无敌超级工程师，那么你需要一个目标：我是要成为超级工程师的男人（妹子）。当你从心底有了这个目标之后，你的每天都会有一种充实感，虽然哥现在很菜，但过一阵子哥可就是大神了。强大先从精神开始。&lt;/p&gt;
&lt;p&gt;#经验与成就&lt;/p&gt;
&lt;p&gt;为什么有的人工作5年，仍然不是专家，而有的人只用2年时间，表现足够卓越？&lt;/p&gt;
&lt;p&gt;心理学家 Ericsson 的研究发现：&lt;strong&gt;决定伟大水平和一般水平的关键因素，既不是天赋，也不是经验，而是[刻意练习]的程度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我坚信重复是通向精通的必由之路。任何一种技能（包括码代码），只要经过连续不断地磨练和改进，最终效果都将变得异常惊人。&lt;/p&gt;
&lt;p&gt;之前也和朋友讨论过一个问题，近几年培训的人越来越多，就业压力相对来说越来越大，很多人会出现恐慌的情绪。但如果你真的足够优秀，那么这种问题其实都不是问题。&lt;/p&gt;
&lt;p&gt;#学好英语&lt;/p&gt;
&lt;p&gt;根据HOPL编程语言在线数据库的统计，全球有8500种以上的编程语言，大概2400种起源于美国，600种是在英国发展起来的，160种是来自加拿大的，75种是在澳大利亚发展起来的。换句话说，世界上三分之一以上的编程语言是在以英语为母语的国家发展起来的。&lt;/p&gt;
&lt;p&gt;就Android开发者来说，&lt;strong&gt;通读官方文档和training都是很有必要的&lt;/strong&gt;。so，好好学习英语吧。&lt;/p&gt;
&lt;p&gt;#找到成就感&lt;/p&gt;
&lt;p&gt;我实习的时候，我的经理告诉我，&lt;strong&gt;如果你从你的工作中找不到成就感，那么你可以考虑转行了。&lt;/strong&gt;对于码代码，在你眼里无论这是一份工作、事业或者志业，都可以赋予其意义。有了意义就会有成就感，它会成为一种精神力量和内在动力，与工作形成一个良好的循环。譬如写博客，如果没有成就感，或许小哥我早放弃了。&lt;/p&gt;
&lt;p&gt;#点满技能点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你不知道该学点什么，去招聘网站翻翻简历吧。&lt;/strong&gt;在你所在的领域里，总会有你不熟悉的技能，找到它，干掉它。&lt;strong&gt;如果你的技能点是满的，那就发散思维，学习一些进阶技能和相关的其他方面的技能点&lt;/strong&gt;，其实开发远比想象的要复杂。&lt;/p&gt;
&lt;p&gt;#好的身体是革命的本钱&lt;/p&gt;
&lt;p&gt;长时间坐在电脑前会伤害你的身体，如果不能减少工作时间，那就尽量保持正确的坐姿，如果有条件的话，换个站立办公桌也是不错的选择。选择一个适合自己的锻炼方案，相信我，当你老了，你会庆幸自己能坚持锻炼。&lt;/p&gt;
&lt;p&gt;#拖延症、计划和时间管理&lt;/p&gt;
&lt;p&gt;拖延症是指自我调节失败，在能够预料后果有害的情况下，仍然把计划要做的事情往后推迟的一种行为。这是一种普遍现象，博主上大学的时候写论文，每次都是在最后一天的最后一两个小时搞完，论文质量简直惨不忍睹。&lt;/p&gt;
&lt;p&gt;我们的人性啊！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合理的计划可以有效的解决拖延症的问题&lt;/strong&gt;，每周给自己一个计划，坚持完成，想不成为大神都难。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学会管理自己的时间，让效率飞起来。&lt;/strong&gt;关于这方面大家可以看下《暗时间》和番茄工作法。&lt;/p&gt;
&lt;p&gt;#知其然与其所以然&lt;/p&gt;
&lt;p&gt;这点很重要，这点很重要，这点很重要，重要的话要说三遍。&lt;/p&gt;
&lt;p&gt;对于这点最深的感触是实习的时候经理提的一点要求：&lt;strong&gt;做任何事，先要想明白，再能给别人讲明白，然后再去执行。&lt;/strong&gt;所以那会我们在做开发之前先要跟他汇报，给他讲明白，然后才能开发。优点也很明显，这样下来bug比之前少很多。&lt;/p&gt;
&lt;p&gt;在这顺便&lt;strong&gt;建议一下大家写博客，做完东西整理思路总结一下，然后分享给大家，加深理解的同时还能获得成就感，一举多得。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#我是这样解决问题的&lt;/p&gt;
&lt;p&gt;首先&lt;strong&gt;遇到问题不要怕，要知道这个世界上那么多前辈，你所遇到的大部分问题，之前肯定有人遇到过并且已经解决，要学会使用google。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其次，这里有一条准则与大家共勉：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;WHAT，WHEN，WHY，HOW。

它是什么？它在什么场景下发生？它为什么会是这样，有没有其他原因？它是怎么做到的？
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果你觉得自己处理信息的能力又比较弱，不妨这样试试。做任何事情之前，有意识的让自己来一遍what, when, why, how。&lt;/p&gt;
&lt;p&gt;时间久了，你会发现逻辑变得严谨，不会钻牛角尖了，工作变得轻松，debug也不头痛了。&lt;/p&gt;
&lt;p&gt;#与时消息、与时谐行、与时俱进&lt;/p&gt;
&lt;p&gt;每天抽出半个小时左右的时间阅读一些领域内的博客, 理解目前的技术发展方向, 与时代同步, 让技术历久弥新。这里分享下我每天必看的&lt;a href=&quot;https://github.com/PleaseCallMeCoder/Topia/blob/master/treasure/recommend.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;博客或者网站&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;#代码评审（code review）&lt;/p&gt;
&lt;p&gt;大多数程序员都有一个错觉：手头上的项目永远是最烂的。如果你也是这么认为，那么尝试去改变它吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码评审（code review）是一个用来提高程序员的极好的方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#开源项目&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阅读流行的开源项目，是学习编写可维护代码和软件开发流程的好方法。&lt;/strong&gt;比如最近流行的google出品的&lt;a href=&quot;https://github.com/googlesamples/android-architecture&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MVP模式demo&lt;/a&gt;，&lt;a href=&quot;https://github.com/greenrobot/EventBus&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EventBus&lt;/a&gt;,&lt;a href=&quot;https://github.com/square/picasso&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Picasso&lt;/a&gt;等等。&lt;/p&gt;
&lt;p&gt;#结语&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;做一个行动派。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;世界上最遥远的距离是在想到和做到之间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果只是看清了一些事情而不去改变它，那又有什么意义呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关注博主是一种态度，评论博主是一种欣赏！！&lt;/p&gt;
&lt;p&gt;最后，欢迎大家关注我的微信公众号：CoderTopia。&lt;/p&gt;
&lt;center&gt;&lt;img style=&quot;width:150px; height:150px&quot; src=&quot;http://img.blog.csdn.net/20160422143030784&quot;&gt;&lt;/center&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;跟大家分享一下成为大神路上的捷径，与诸君共勉。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="方法论" scheme="http://yoursite.com/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
      <category term="方法论" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="学习方法" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>TextView实战之你真的懂我么？</title>
    <link href="http://yoursite.com/2016/05/04/TextView%E5%AE%9E%E6%88%98%E4%B9%8B%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82%E6%88%91%E4%B9%88%EF%BC%9F/"/>
    <id>http://yoursite.com/2016/05/04/TextView实战之你真的懂我么？/</id>
    <published>2016-05-04T10:40:00.000Z</published>
    <updated>2016-11-10T03:54:20.678Z</updated>
    
    <content type="html">&lt;p&gt;对于TextView,我想大家都已经熟的不能再熟了。但是它的用法我们真的熟么？为了避免总是一言不合就去翻官方文档，在这里我总结一下我也可能是你容易忽视的一些细节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/j1Knx9T.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不要以为别人是赢在了起跑线上，他们其实生在了终点。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#写在前面的话&lt;/p&gt;
&lt;p&gt;对于TextView,我想大家都已经熟的不能再熟了。但是它的用法我们真的熟么？为了避免总是一言不合就去翻官方文档，在这里我总结一下我也可能是你容易忽视的一些细节.&lt;/p&gt;
&lt;p&gt;#TextView设置基础&lt;/p&gt;
&lt;p&gt;##字符串资源里变量替换&lt;/p&gt;
&lt;p&gt;Android开发中是拒绝硬编码的，我们可能会把一些字符串放在xml中当作资源使用，假设有如下情况：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;string name=&amp;quot;welcome&amp;quot;&amp;gt;你好A，欢迎使用我们的App。&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们在程序中需要使用这个字符串，但是A是一个变量，很常规的办法是取出这个字符串，然后用String的replace方法把A替换成用户的昵称。&lt;/p&gt;
&lt;p&gt;其实，在android中有这样一个东西，那就是 XLIFF，全称叫 XML &lt;strong&gt;本地化数据交换格式&lt;/strong&gt;，英文全称 XML Localization Interchange File Format。&lt;/p&gt;
&lt;p&gt;用法也是很简单的，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;string name=&amp;quot;welcome&amp;quot;&amp;gt;你好%1$s，欢迎使用我们的App。&amp;lt;/string&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;程序中只要给变量赋值就可以了，如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String welcome = getString(R.string.welcome, &amp;quot;小丸子&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;把字符串打印出来如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/0Aho7n7.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这里的1代表第一个变量，多个变量的话依次递增即可。&lt;/p&gt;
&lt;p&gt;##TextView xml文件可配置的属性&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android:autoLink    设置是否当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接。可选值(none/web/email/phone/map/all)  
android:autoText    如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。  
android:bufferType  指定getText()方式取得的文本类别。选项editable 类似于StringBuilder可追加字符，  
也就是说getText后可调用append方法设置文本内容。spannable 则可在给定的字符区域使用样式，参见这里1、这里2。  

android:capitalize  设置英文字母大写类型。此处无效果，需要弹出输入法才能看得到，参见EditView此属性说明。  
android:cursorVisible   设定光标为显示/隐藏，默认显示。  
android:digits  设置允许输入哪些字符。如“1234567890.+-*/%\n()”  
android:drawableBottom  在text的下方输出一个drawable，如图片。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。  
android:drawableLeft    在text的左边输出一个drawable，如图片。  
android:drawablePadding 设置text与drawable(图片)的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。  
android:drawableRight   在text的右边输出一个drawable，如图片。  
android:drawableTop 在text的正上方输出一个drawable，如图片。  
android:editable    设置是否可编辑。这里无效果，参见EditView。  
android:editorExtras    设置文本的额外的输入数据。在EditView再讨论。  
android:ellipsize   设置当文字过长时,该控件该如何显示。有如下值设置：”start”—–省略号显示在开头；”end”——省略号显示在结尾；”middle”—-省略号显示在中间；”marquee” ——以跑马灯的方式显示(动画横向移动)  

android:freezesText 设置保存文本的内容以及光标的位置。参见：这里。  

android:gravity 设置文本位置，如设置成“center”，文本将居中显示。  
android:hint    Text为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。此属性在EditView中使用，但是这里也可以用。  
android:imeOptions  附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。这个在EditView中再详细说明，此处无用。  
android:imeActionId 设置IME动作ID。在EditView再做说明，可以先看这篇帖子：这里。  

android:imeActionLabel  设置IME动作标签。在EditView再做说明。  
android:includeFontPadding  设置文本是否包含顶部和底部额外空白，默认为true。  
android:inputMethod 为文本指定输入法，需要完全限定名（完整的包名）。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。  
android:inputType   设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。  
android:marqueeRepeatLimit  在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。  
android:ems 设置TextView的宽度为N个字符的宽度。这里测试为一个汉字字符宽度，如图：   
android:maxEms  设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。  
android:minEms  设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。  
android:maxLength   限制显示的文本长度，超出部分不显示。  
android:lines   设置文本的行数，设置两行就显示两行，即使第二行没有数据。  
android:maxLines    设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。  
android:minLines    设置文本的最小行数，与lines类似。  
android:linksClickable  设置链接是否点击连接，即使设置了autoLink。  
android:lineSpacingExtra    设置行间距。  
android:lineSpacingMultiplier   设置行间距的倍数。如”1.2”  
android:numeric 如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。  
android:password    以小点”.”显示文本  
android:phoneNumber 设置为电话号码的输入方式。  
android:privateImeOptions   设置输入法选项，此处无用，在EditText将进一步讨论。  
android:scrollHorizontally  设置文本超出TextView的宽度的情况下，是否出现横拉条。  
android:selectAllOnFocus    如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。  
android:shadowColor 指定文本阴影的颜色，需要与shadowRadius一起使用。效果：    
android:shadowDx    设置阴影横向坐标开始位置。  
android:shadowDy    设置阴影纵向坐标开始位置。  
android:shadowRadius    设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。  
android:singleLine  设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=&amp;quot;test_ singleLine &amp;quot; android:singleLine=&amp;quot;true&amp;quot; android:layout_width=&amp;quot;20dp&amp;quot;将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行  
android:text    设置显示文本.  
android:textAppearance  设置文字外观。如“?android:attr/textAppearanceLargeInverse  
”这里引用的是系统自带的一个外观，？表示系统是否有这种外观，否则使用默认的外观。可设置的值如下：textAppearanceButton/textAppearanceInverse/textAppearanceLarge/textAppearanceLargeInverse/textAppearanceMedium/textAppearanceMediumInverse/textAppearanceSmall/textAppearanceSmallInverse  
android:textColor   设置文本颜色  
android:textColorHighlight  被选中文字的底色，默认为蓝色  
android:textColorHint   设置提示信息文字的颜色，默认为灰色。与hint一起使用。  
android:textColorLink   文字链接的颜色.  
android:textScaleX  设置文字之间间隔，默认为1.0f。分别设置0.5f/1.0f/1.5f/2.0f效果如下：  

android:textSize    设置文字大小，推荐度量单位”sp”，如”15sp”  
android:textStyle   设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开  
android:typeface    设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3]   
android:height  设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)  
android:maxHeight   设置文本区域的最大高度  
android:minHeight   设置文本区域的最小高度  
android:width   设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)，与layout_width的区别看这里。  

android:maxWidth    设置文本区域的最大宽度  
android:minWidth    设置文本区域的最小宽度  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##TextView中设置多种字体大小&lt;/p&gt;
&lt;p&gt;比如在项目中经常遇到如下UI，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/TmmIXah.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;像这样的两种字体大小放到一个TextView中，我们应该如何处理呢？需要用到 android.text 命名空间下的一些与 &lt;a href=&quot;http://developer.android.com/reference/android/text/Spannable.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;spannable&lt;/a&gt;相关的类和接口。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String text = &amp;quot;您已经连续走了5963步&amp;quot;;
int start = text.indexOf(&amp;apos;5&amp;apos;);
int end = text.length();
Spannable textSpan = new SpannableStringBuilder(text);
textSpan.setSpan(new AbsoluteSizeSpan(16), 0, start, Spannable.SPAN_INCLUSIVE_INCLUSIVE);
textSpan.setSpan(new AbsoluteSizeSpan(26), start, end - 1, Spannable.SPAN_INCLUSIVE_INCLUSIVE);
textSpan.setSpan(new AbsoluteSizeSpan(16), end - 1, end, Spannable.SPAN_INCLUSIVE_INCLUSIVE);
TextView textView = (TextView) findViewById(R.id.text);
textView.setText(textSpan);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个经过转化过的textSpan就是我们需要的。&lt;/p&gt;
&lt;p&gt;##TextView中设置超链接&lt;/p&gt;
&lt;p&gt;这个比较简单，设置我们上边提到的android:autoLink属性，默认为none。该属性的几个常量如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/2qx3b5t.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码中的设置方式：setAutoLinkMask(int)。&lt;/p&gt;
&lt;p&gt;参数和上边列表对应，分别为：Linkify.WEB_URLS，Linkify.EMAIL_ADDRESSES，Linkify.PHONE_NUMBERS，Linkify.MAP_ADDRESSES，Linkify.ALL&lt;/p&gt;
&lt;p&gt;但是需要注意的是，当我们需要&lt;strong&gt;定制超链接的跳转&lt;/strong&gt;时应该怎么做？答案是还是选择Spannable。代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//将TextView的显示文字设置为SpannableString
testText.setText(getClickableSpan());
//设置该句使文本的超连接起作用
testText.setMovementMethod(LinkMovementMethod.getInstance());

//设置超链接文字
private SpannableString getClickableSpan() {
    SpannableString spanStr = new SpannableString(&amp;quot;使用该软件，即表示您同意该软件的使用条款和隐私政策&amp;quot;);
    //设置下划线文字
    spanStr.setSpan(new UnderlineSpan(), 16, 20, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    //设置文字的单击事件
    spanStr.setSpan(new ClickableSpan() {
        @Override
        public void onClick(View widget) {
            startActivity(new Intent(MainActivity.this, UsageActivity.class));
        }
    }, 16, 20, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    //设置文字的前景色
    spanStr.setSpan(new ForegroundColorSpan(Color.GREEN), 16, 20, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

    //设置下划线文字
    spanStr.setSpan(new UnderlineSpan(), 21, 25, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    //设置文字的单击事件
    spanStr.setSpan(new ClickableSpan() {
        @Override
        public void onClick(View widget) {
            startActivity(new Intent(MainActivity.this, PrivacyActivity.class));
        }
    }, 21, 25, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
    //设置文字的前景色
    spanStr.setSpan(new ForegroundColorSpan(Color.GREEN), 21, 25, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);

    return spanStr;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/4zFQKCI.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##插入图片&lt;/p&gt;
&lt;p&gt;Android中可以使用TextView的drawableXXX属性在文字周围插入图片。图片和文字之间的间距可以通过android:drawablePadding来设置。&lt;/p&gt;
&lt;p&gt;xml中属性为:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android:drawableLeft
android:drawableTop
android:drawableRight
android:drawableBottom
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码中的设置方式：setCompoundDrawablesWithIntrinsicBounds(int left, int top, int right, int bottom)。&lt;/p&gt;
&lt;p&gt;left，top等需传入资源id，不需要的话传0.&lt;/p&gt;
&lt;p&gt;##阴影&lt;/p&gt;
&lt;p&gt;Android中设置阴影也比较简单，xml中可以这样设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android:shadowColor //指定文本阴影的颜色
android:shadowDx //设置阴影横向坐标开始位置
android:shadowDy //设置阴影纵向坐标开始位置
android:shadowRadius //设置阴影的半径。设置为0.1会变成字体的颜色
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码中通过方法public void setShadowLayer (float radius, float dx, float dy, int color)来设置。&lt;/p&gt;
&lt;p&gt;我的参数是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android:shadowColor=&amp;quot;#ffffff&amp;quot;
android:shadowDx=&amp;quot;15.0&amp;quot;
android:shadowDy=&amp;quot;5.0&amp;quot;
android:shadowRadius=&amp;quot;2.5&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/2P3F5Ll.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##字体加粗或者倾斜&lt;/p&gt;
&lt;p&gt;在xml布局文件中使用android:textStyle=”bold”可以将文字设置成粗体。在代码中设置的方法是：使用TextPaint的仿“粗体”设置setFakeBoldText为true。示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tv.getPaint().setFakeBoldText(true);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;textstyle可设置的属性有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/gfTStsK.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;italic为倾斜，多属性可用”|”分开。&lt;/p&gt;
&lt;p&gt;##文字过长显示省略号或者跑马灯效果&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android:maxEms=&amp;quot;6&amp;quot; //限制显示的字符长度

android:singleLine=&amp;quot;true&amp;quot; //单行显示

android:ellipsize=&amp;quot;end&amp;quot;//在结尾用省略号
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;android:ellipsize设置当文字过长时,该控件该如何显示。有如下值设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;”start”—–省略号显示在开头；&lt;/li&gt;
&lt;li&gt;”end”——省略号显示在结尾；&lt;/li&gt;
&lt;li&gt;”middle”—-省略号显示在中间；&lt;/li&gt;
&lt;li&gt;”marquee” ——以跑马灯的方式显示(动画横向移动)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;android:marqueeRepeatLimit 在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。实现需要控件获得焦点。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;android:marqueeRepeatLimit=&amp;quot;marquee_forever&amp;quot;
android:ellipsize=&amp;quot;marquee&amp;quot;
android:singleLine=&amp;quot;true&amp;quot;
android:focusableInTouchMode=&amp;quot;true&amp;quot;
android:focusable=&amp;quot;true&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/lqd62Ox.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##设置行间距&lt;/p&gt;
&lt;p&gt;1、android:lineSpacingExtra&lt;br&gt;   设置行间距，如”3dp”。&lt;/p&gt;
&lt;p&gt;2、android:lineSpacingMultiplier&lt;br&gt;   设置行间距的倍数，如”1.2″。&lt;/p&gt;
&lt;p&gt;##关于字体&lt;/p&gt;
&lt;p&gt;我们可以通过设置android:typeface属性来控制字体，可以设置为normal, sans, serif, monospace四种。具体如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/5CrEoYl.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码中可以通过setTypeface(Typeface)方法设置。但有时候我们的App可能需要使用特殊的字体，这时候怎么办呢？可以通过如下代码设置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Typeface mTypeFace = Typeface.createFromAsset(getAssets(), &amp;quot;kaiti.ttf&amp;quot;);
textview.setTypeface(mTypeFace);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后将我们的字体文件放到assets文件夹下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是需要注意的是，不要大量使用这种自定义字体，因为自定义字体会消耗更多的性能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#TextView中设置Html&lt;/p&gt;
&lt;p&gt;##TextView支持的Html标签&lt;/p&gt;
&lt;p&gt;Textview只支持部分的html标签。具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&amp;quot;...&amp;quot;&amp;gt;  //定义链接内容
&amp;lt;b&amp;gt; //定义粗体文字   b 是blod的缩写
&amp;lt;big&amp;gt; //定义大字体的文字
&amp;lt;blockquote&amp;gt; //引用块标签 
&amp;lt;br&amp;gt; //定义换行
&amp;lt;cite&amp;gt; //表示引用的URI
&amp;lt;dfn&amp;gt; //定义标签  dfn 是defining instance的缩写
&amp;lt;div align=&amp;quot;...&amp;quot;&amp;gt;
&amp;lt;em&amp;gt; //强调标签  em 是emphasis的缩写
&amp;lt;font color=&amp;quot;...&amp;quot; face=&amp;quot;...&amp;quot;&amp;gt;//不支持size属性
&amp;lt;h1&amp;gt;
&amp;lt;h2&amp;gt;
&amp;lt;h3&amp;gt;
&amp;lt;h4&amp;gt;
&amp;lt;h5&amp;gt;
&amp;lt;h6&amp;gt;
&amp;lt;i&amp;gt; //定义斜体文字
&amp;lt;img src=&amp;quot;...&amp;quot;&amp;gt;
&amp;lt;p&amp;gt; // 段落标签,里面可以加入文字,列表,表格等
&amp;lt;small&amp;gt; //定义小字体的文字
&amp;lt;strike&amp;gt; // 定义删除线样式的文字   不符合标准网页设计的理念,不赞成使用.   strike是strikethrough的缩写
&amp;lt;strong&amp;gt; //重点强调标签
&amp;lt;sub&amp;gt; //下标标签   sub 是subscript的缩写
&amp;lt;sup&amp;gt; //上标标签   sup 是superscript的缩写
&amp;lt;tt&amp;gt; //定义monospaced字体的文字  不赞成使用.  此标签对中文没意义  tt是teletype or monospaced text style的意思
&amp;lt;u&amp;gt; //定义带有下划线的文字  u是underlined text style的意思
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##显示多种颜色的字&lt;/p&gt;
&lt;p&gt;Android支持html格式的字符串，通过调用Html.fromHtml(str)方法可以转换html格式的字符串str。示例代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TextView textth = (TextView) findViewById(R.id.textth);
String textStr1 = &amp;quot;&amp;lt;font color=\&amp;quot;#123569\&amp;quot;&amp;gt;如果有一天，&amp;lt;/font&amp;gt;&amp;quot;;
String textStr2 = &amp;quot;&amp;lt;font color=\&amp;quot;#00ff00\&amp;quot;&amp;gt;我悄然离去&amp;lt;/font&amp;gt;&amp;quot;;
textth.setText(Html.fromHtml(textStr1 + textStr2));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/RA5ZYDX.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;##字体加粗&lt;/p&gt;
&lt;p&gt;字体加粗还可以通过设置html格式字符串来实现&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String textStr1 = &amp;quot;&amp;lt;b&amp;gt;sdfa&amp;lt;/b&amp;gt;&amp;quot;;
textth.setText(Html.fromHtml(textStr1));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;##插入图片&lt;/p&gt;
&lt;p&gt;插入图片还可以用html字符串来实现。不过需要用到ImageGetter类来对图片的src属性进行转换。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;String imgStr = &amp;quot;&amp;lt;b&amp;gt;sdfa&amp;lt;/b&amp;gt;&amp;lt;br&amp;gt;&amp;lt;img src=\&amp;quot;&amp;quot; + R.mipmap.ic_launcher + &amp;quot;\&amp;quot;/&amp;gt;&amp;quot;;
Html.ImageGetter imageGetter = new Html.ImageGetter() {
        @Override
        public Drawable getDrawable(String source) {
            int id = Integer.parseInt(source);
            Drawable draw = getResources().getDrawable(id);
            draw.setBounds(0, 0, 300, 200);
            return draw;
        }
 };
 TextView textfi = (TextView) findViewById(R.id.textfiv);
 textfi.append(Html.fromHtml(imgStr, imageGetter, null));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/pmkepiS.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;右边的sdfa是通过html来加粗的，下边的图片是通过html插入的。&lt;/p&gt;
&lt;p&gt;#结语&lt;/p&gt;
&lt;p&gt;关注博主是一种态度，评论博主是一种欣赏！！&lt;/p&gt;
&lt;p&gt;最后，欢迎大家关注我的微信公众号：CoderTopia。&lt;/p&gt;
&lt;center&gt;&lt;img style=&quot;width:150px; height:150px&quot; src=&quot;http://img.blog.csdn.net/20160422143030784&quot;&gt;&lt;/center&gt;


&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://developer.android.com/reference/android/widget/TextView.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/reference/android/widget/TextView.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/mxgsa/tag/TextView/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/mxgsa/tag/TextView/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.360doc.com/content/13/0620/17/12712639_294320421.shtml&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.360doc.com/content/13/0620/17/12712639_294320421.shtml&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/y1258429182/article/details/50806750&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/y1258429182/article/details/50806750&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;对于TextView,我想大家都已经熟的不能再熟了。但是它的用法我们真的熟么？为了避免总是一言不合就去翻官方文档，在这里我总结一下我也可能是你容易忽视的一些细节。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="原生控件属性" scheme="http://yoursite.com/categories/%E5%8E%9F%E7%94%9F%E6%8E%A7%E4%BB%B6%E5%B1%9E%E6%80%A7/"/>
    
    
      <category term="TextView" scheme="http://yoursite.com/tags/TextView/"/>
    
      <category term="原生控件属性" scheme="http://yoursite.com/tags/%E5%8E%9F%E7%94%9F%E6%8E%A7%E4%BB%B6%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>Andorid自定义圆形渐变色进度条的从实现到开源</title>
    <link href="http://yoursite.com/2016/04/29/Andorid%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9C%86%E5%BD%A2%E6%B8%90%E5%8F%98%E8%89%B2%E8%BF%9B%E5%BA%A6%E6%9D%A1%E7%9A%84%E4%BB%8E%E5%AE%9E%E7%8E%B0%E5%88%B0%E5%BC%80%E6%BA%90/"/>
    <id>http://yoursite.com/2016/04/29/Andorid自定义圆形渐变色进度条的从实现到开源/</id>
    <published>2016-04-29T06:31:00.000Z</published>
    <updated>2016-09-06T06:23:52.522Z</updated>
    
    <content type="html">&lt;p&gt;Andorid自定义圆形渐变色进度条的从实现到开源的全过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/5tRNY53.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信自己也是一种信仰&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;#写在前面的话&lt;/p&gt;
&lt;p&gt;3月初我在自定义控件概述中挖下的几个坑，前一段时间已经基本填完了，自定义控件的几种实现方式也分别写了demo来进行说明。今天我们来聊一聊如何把&lt;strong&gt;自己封装一个圆形渐变色进度条控件开源到github，并且上传到jcenter方便别人远程依赖&lt;/strong&gt;。先看下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/N0ckzIs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;#连接github并提交新项目&lt;/p&gt;
&lt;p&gt;前提条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装Git客户端（&lt;a href=&quot;https://git-scm.com/downloads/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;有&lt;a href=&quot;https://github.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;账号 &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;创建新项目并提交到Github：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在AndroidStudio中新建一个项目&lt;/li&gt;
&lt;li&gt;配置Git:Settings -&amp;gt; Version Control -&amp;gt; Git ,设置git目录,点击Test测试,如果成功会有Success提示&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/Wv6s1jw.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;关联自己的Github账号：Settring -&amp;gt; VersionControl -&amp;gt;GitHub,设置自己的github账号,密码,点击Test测试,如果成功会有Success提示&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/7ZGSmgQ.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;
&lt;li&gt;分享项目:VCS -&amp;gt; Import into Version Control -&amp;gt; Share Project on GitHub, 点击之后开始设置 repository name(如果你有设置过MasterPassword 会弹出对话框让填入密码)&lt;br&gt;&lt;img src=&quot;http://i.imgur.com/kg5inwD.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;点击Share之后, 你就可以在GitHub上看到新的仓库，同时在AndroidStudio中CVS下也可以看到版本控制Git，这样就已经设置成功。&lt;/li&gt;
&lt;li&gt;如果你想解除关联,只需要Settrings -&amp;gt; Version Control删掉关联就可以了。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;#完成circlebar代码&lt;br&gt;接下来我们来实现我们的圆形渐变色进度条，需要的技能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Canvas绘图基础&lt;/li&gt;
&lt;li&gt;Shader绘制渐变色&lt;/li&gt;
&lt;li&gt;绘制进度条的原理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Canvas绘图基础&lt;/p&gt;
&lt;p&gt;关于Canvas绘图，网上的教程很多，这里大概的说一下都有哪些点需要了解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Canvas坐标系与绘图坐标系。&lt;/li&gt;
&lt;li&gt;drawARGB：Canvas中的drawARGB可以用来对整个Canvas以某种统一的颜色整体绘制，四个参数分别是Alpha、Red、Green、Blue，取值都是0-255。&lt;/li&gt;
&lt;li&gt;drawText：Canvas中用drawText方法绘制文字。&lt;/li&gt;
&lt;li&gt;drawPoint：Canvas中用drawPoint方法绘制点。&lt;/li&gt;
&lt;li&gt;drawLine：Canvas通过drawLine方法绘制一条线段，通过drawLines方法绘制多段线。&lt;/li&gt;
&lt;li&gt;drawRect：Canvas通过drawRect方法绘制矩形。&lt;/li&gt;
&lt;li&gt;drawCircle：Canvas中用drawCircle方法绘制圆形。&lt;/li&gt;
&lt;li&gt;drawOval：Canvas中提供了drawOval方法绘制椭圆。&lt;/li&gt;
&lt;li&gt;drawArc：Canvas中提供了drawArc方法用于绘制弧，这里的弧指两种：弧面和弧线，弧面即用弧围成的填充面，弧线即为弧面的轮廓线。&lt;/li&gt;
&lt;li&gt;drawPath：Canvas通过drawPath方法可以绘制Path。那Path是什么呢？Path致以过来是路径的意思，在Android中，Path是一种线条的组合图形，其可以由直线、二次曲线、三次曲线、椭圆的弧等组成。Path既可以画线条，也可以画填充面。&lt;/li&gt;
&lt;li&gt;drawBitmap：Canvas中提供了drawBitmap方法用于绘制Bitmap。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Paint和Shader&lt;/p&gt;
&lt;p&gt;###Paint&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;画笔Paint控制着所绘制的图形的具体外观，Paint默认的字体大小为12px，在绘制文本时我们往往要考虑密度density设置合适的字体大小。画笔的默认颜色为黑色，默认的style为FILL，默认的cap为BUTT，默认的线宽为0.&lt;/li&gt;
&lt;li&gt;在画面状的图形时，如果Paint的style是FILL，那么绘制的就是填充面；如果是STROKE，那么绘制的就是轮廓线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###Shader&lt;/p&gt;
&lt;p&gt;androd 提供了Shader类专门用来渲染图像以及一些几何图形。Shader下面包括几个直接子类，分别是BitmapShader、 ComposeShader、LinearGradient、RadialGradient、SweepGradient。BitmapShader主要用来渲染图像，LinearGradient 用来进行梯度渲染，RadialGradient 用来进行环形渲染，SweepGradient 用来进行梯度渲染，ComposeShader则是一个 混合渲染，可以和其它几个子类组合起来使用。&lt;/p&gt;
&lt;p&gt;Shader类的使用，都需要先构建Shader对象，然后通过Paint的setShader方法设置渲染对象，然后设置渲染对象，然后再绘制时使用这个Paint对象即可。&lt;/p&gt;
&lt;p&gt;##绘制进度条&lt;/p&gt;
&lt;p&gt;talk is cheap，show you my code。下面说一下绘制圆形渐变进度条的过程。&lt;/p&gt;
&lt;p&gt;首先先跟大家说下原理，我们的主要绘制过程其实非常简单，&lt;strong&gt;调用drawArc方法绘制圆弧&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;先来说下drawArc方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
  * 绘制弧
  * drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint)
  * oval是RecF类型的对象，其定义了椭圆的形状
  * startAngle指的是绘制的起始角度，钟表的3点位置对应着0度，如果传入的startAngle小于0或者大于等于360，那么用startAngle对360进行取模后作为起始绘制角度。
  * sweepAngle指的是从startAngle开始沿着钟表的顺时针方向旋转扫过的角度。如果sweepAngle大于等于360，那么会绘制完整的椭圆环。如果sweepAngle小于0，那么会用sweepAngle对360进行取模后作为扫过的角度。
  * useCenter是个boolean值，如果为true，表示在绘制完环之后，用椭圆的中心点连接环上的起点和终点以闭合环；如果值为false，表示在绘制完环之后，环的起点和终点直接连接，不经过椭圆的中心点。
  */    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;里边需要传一个定义好的矩形&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
  *RectF rectF = new RectF(100, 100, 300, 300);
  * 这四个参数分别代表的意思是：left   top   right   bottom  左 上 右 下
  * left ： 矩形左边的X坐标
  * top:    矩形顶部的Y坐标
  * right :  矩形右边的X坐标
  * bottom： 矩形底部的Y坐标
  * 其实就是矩形的左上角和右下角的坐标值
  */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们来看一个小例子，自定义view，在ondraw中调用如下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//绘制矩形框和圆弧
private void drawArc(Canvas canvas) {

    canvas.drawARGB(255, 56, 197, 186);

    RectF rectF = new RectF(100, 100, 300, 300);

    paint.setStrokeWidth(1 * density);//设置线宽
    paint.setColor(0xFF6BB7ED);//设置颜色
    paint.setStyle(Paint.Style.FILL);//默认设置画笔为填充模式

    //绘制椭圆
    paint.setStyle(Paint.Style.STROKE);//设置画笔为线条模式
    canvas.drawArc(rectF, 0, 359, false, paint);

    paint.setStrokeWidth(1 * density);//设置线宽
    paint.setColor(0xff8bc5ba);//设置颜色
    paint.setStyle(Paint.Style.STROKE);//默认设置画笔为填充模式

    canvas.drawRect(rectF, paint);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/VJ0oCyl.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们看到当我们以同一个矩形rectF为基准画了一个圆弧和矩形，圆弧正好为矩形的内切圆。这时候我们增大圆弧的线宽为21*density。效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/MoYmQXp.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到圆弧以矩形为基准宽度向矩形外和矩形内各增大了10*density。&lt;/p&gt;
&lt;p&gt;这时候我们以rectF为基准再多画一个圆弧。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; paint.setStrokeWidth(11 * density);//设置线宽
paint.setColor(0xFF303f9f);//设置颜色
paint.setStyle(Paint.Style.FILL);//默认设置画笔为填充模式
paint.setStrokeCap(Paint.Cap.ROUND);

paint.setStyle(Paint.Style.STROKE);//设置画笔为线条模式
canvas.drawArc(rectF, 0, 270, false, paint);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/0jJRZy2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;perfect！可以看到我们要的效果基本已经出来了。&lt;/p&gt;
&lt;p&gt;然后说一下具体的一些细节。&lt;/p&gt;
&lt;p&gt;onmeasure，我们在里边去设置控件的大小为正方形：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {

    int height = getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec);
    int width = getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec);
    int min = Math.min(width, height);// 获取View最短边的长度
    setMeasuredDimension(min, min);// 强制改View为以最短边为长度的正方形

    circleStrokeWidth = Textscale(35, min);// 圆环的宽度
    pressExtraStrokeWidth = Textscale(2, min);// 圆环离矩形的距离
    /**
     * 这四个参数分别代表的意思是：left   top   right   bottom  左 上 右 下
     * left ： 矩形左边的X坐标
     * top:    矩形顶部的Y坐标
     * right :  矩形右边的X坐标
     * bottom： 矩形底部的Y坐标
     * 其实就是矩形的左上角和右下角的坐标值
     */
    mColorWheelRectangle.set(circleStrokeWidth + pressExtraStrokeWidth,
            circleStrokeWidth + pressExtraStrokeWidth, min
                    - circleStrokeWidth - pressExtraStrokeWidth, min
                    - circleStrokeWidth - pressExtraStrokeWidth);// 设置圆环内圆的外接正方形
    mColorWheelPaint.setStrokeWidth(circleStrokeWidth - 5);
    mColorWheelPaintCentre.setStrokeWidth(circleStrokeWidth + 5);
    mDefaultWheelPaint.setStrokeWidth(circleStrokeWidth - Textscale(2, min));
    mDefaultWheelPaint.setShadowLayer(Textscale(10, min), 0, 0, Color.rgb(127, 127, 127));// 设置阴影
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定义了一个setShaderColor方法来设置渐变色，这里我们用梯度渐变。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 设置渐变色
 *
 * @param shaderColor
 */
public void setShaderColor(int[] shaderColor) {
    this.mColors = shaderColor;
    Shader newShader = new SweepGradient(0, 0, mColors, null);
    mColorWheelPaint.setShader(newShader);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后继承Animation类自定义一个动画效果，即根据进度计算角度，来慢慢绘制我们的进度条。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 进度条动画
 *
 * @author Administrator
 */
public class BarAnimation extends Animation {
    public BarAnimation() {

    }

    /**
     * 每次系统调用这个方法时， 改变mSweepAnglePer，mPercent，stepnumbernow的值，
     * 然后调用postInvalidate()不停的绘制view。
     */
    @Override
    protected void applyTransformation(float interpolatedTime,
                                       Transformation t) {
        super.applyTransformation(interpolatedTime, t);
        if (interpolatedTime &amp;lt; 1.0f) {
            mPercent = Float.parseFloat(fnum.format(interpolatedTime
                    * stepnumber * 100f / stepnumbermax));// 将浮点值四舍五入保留一位小数
            mSweepAnglePer = interpolatedTime * stepnumber * 360
                    / stepnumbermax;
            stepnumbernow = (int) (interpolatedTime * stepnumber);
        } else {
            mPercent = Float.parseFloat(fnum.format(stepnumber * 100f
                    / stepnumbermax));// 将浮点值四舍五入保留一位小数
            mSweepAnglePer = stepnumber * 360 / stepnumbermax;
            stepnumbernow = stepnumber;
        }
        postInvalidate();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;好了，到这里我们的自定义圆形渐变色进度条就完全搞定了。&lt;/p&gt;
&lt;p&gt;#上传到jcenter&lt;/p&gt;
&lt;p&gt;上传到jcenter，我用的是bintray-release这个插件。这里可以参考这篇：&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/51148825&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/lmj623565791/article/details/51148825&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;注册bintray.com账号，&lt;a href=&quot;https://bintray.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;注册地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;引入bintray-release，在需要上传的module里面填写相关publish的信息&lt;/li&gt;
&lt;li&gt;调用上传的命令&lt;/li&gt;
&lt;li&gt;Add to Jcenter提交审核&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;需要注意的是，这里我遇到了一个问题，在这里跟大家分享一下，即当我上传的moudle中带有中文注释，编码为utf-8的时候，上传会抛出异常，然后上传失败。从网上也没有找到太好的解决办法，最后我把中文中是全部删掉才上传成功。如果你有好的解决办法，请告诉我0.0&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;#结语&lt;/p&gt;
&lt;p&gt;代码我已经上传到了github，github中有说明文档，欢迎Star、Fork。链接：&lt;a href=&quot;https://github.com/PleaseCallMeCoder/CircleProgressBar&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/PleaseCallMeCoder/CircleProgressBar&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，欢迎大家关注我的微信公众号：CoderTopia。&lt;/p&gt;
&lt;center&gt;&lt;img style=&quot;width:150px; height:150px&quot; src=&quot;http://img.blog.csdn.net/20160422143030784&quot;&gt;&lt;/center&gt;

&lt;p&gt;参考链接：&lt;br&gt;&lt;a href=&quot;http://www.androidchina.net/3919.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.androidchina.net/3919.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/lmj623565791/article/details/51148825&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/lmj623565791/article/details/51148825&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Andorid自定义圆形渐变色进度条的从实现到开源的全过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="自定义控件" scheme="http://yoursite.com/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
    
      <category term="自定义控件" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
      <category term="原形渐变色进度条" scheme="http://yoursite.com/tags/%E5%8E%9F%E5%BD%A2%E6%B8%90%E5%8F%98%E8%89%B2%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之Performance Tips</title>
    <link href="http://yoursite.com/2016/04/26/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8BPerformance%20Tips/"/>
    <id>http://yoursite.com/2016/04/26/Android性能优化之Performance Tips/</id>
    <published>2016-04-26T03:01:00.000Z</published>
    <updated>2016-05-06T14:02:01.401Z</updated>
    
    <content type="html">&lt;p&gt;这篇文章主要是对官方文档中PerformanceTips（性能优化关键点）的翻译，欢迎拍砖。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/uWNFnJF.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果你真的愿意去努力，你人生最坏的结果，也不过是大器晚成。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://developer.android.com/training/articles/perf-tips.html#UseFinal&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/training/articles/perf-tips.html#UseFinal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#概述&lt;/p&gt;
&lt;p&gt;这篇文档主要包含一些微小的最佳优化,当把这些组合起来的时候，可以提高App的整体性能，但它不太可能对性能造成戏剧性的影响。选择合适的算法和数据结构应该是你优先考虑的内容,但超出了本文的范围。这个文档更适合作为通用的编码技巧,通过这些技巧使我们的代码更高效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写高效代码有两个基本规则:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不执行不必要的操作&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;不分配不必要的内存&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们面临的最棘手的一个问题是我们的Android应用程序肯定会在多种类型的硬件上运行。不同版本的VM虚拟机运行在不同的处理器的运行速度显然是不同的。你甚至不能简单地说“设备X快/慢于设备Y大概F倍”，然后想当然的认为其在他设备上这个倍数也是成立的。但是,我们仅仅能从模拟器获得很少关于设备性能的信息，它与真机还是有很大不同的。还有,有或没有JIT（即时编译）的设备之间存在巨大差异:在有JIT的设备上完美运行的代码在没有JIT的设备上并不一定能顺畅运行。&lt;/p&gt;
&lt;p&gt;我们要尽量通过优化性能来确保我们的应用在各种各样的设备上都表现良好,确保代码在支持的不同版本上是有效的。&lt;/p&gt;
&lt;p&gt;#避免创建不必要的对象&lt;/p&gt;
&lt;p&gt;对象创建永远不会是免费的。虽然一个带有线程池的垃圾回收器（garbage collector）可以使分配临时对象的内存占用降低,但分配内存总是比不分配内存更昂贵的。&lt;/p&gt;
&lt;p&gt;当我们在我们的应用分配更多的对象时,将迫使一个周期性的垃圾回收,创建“打嗝”的用户体验，即卡顿。在Android 2.3中引入的并发垃圾收集器（GC）可以帮助我们,但不必要的工作能避免要尽量避免。&lt;/p&gt;
&lt;p&gt;因此,这样我们应该避免创建我们不需要的对象，以下是一些实例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你有一个方法返回一个字符串,你知道它的结果需要附加到StringBuffer上,改变你的实现方法使它可以直接添加,而不是创建一个短暂的临时对象。&lt;/li&gt;
&lt;li&gt;当要从一组输入数据中提取字符串时,试着返回一个原始数据的子字符串（substring）,而不是创建一个重复的对象。使用substring的方式，你将创建一个新的String对象，但它将与原数据共享内部char[]空间的。（如果你只使用原始输入的一小部分，无论怎么操作，你都会把它保持在内存中，这点需要权衡）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一个更激进的想法是把一个多维数组分割成平行的一维数组:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int类型的数组比Integer对象数组要好，由此可以知道两个平行的int数组比(int,int)二维数组效率更高。这同样适用于所有的原始数据类型。&lt;/li&gt;
&lt;li&gt;如果你需要实现一个容器存储(Foo,Bar)对象的，试着记住两个平行的Foo[]和Bar[]数组通常比单一阵列的自定义(Foo,Bar)对象要好。（但是有例外,比如当你设计一个API访问其他代码的时候。在这些情况下,通常可以牺牲小部分的性能达到良好的API设计。但在自己的内部代码,我们应该试着尽可能的提高效率。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说,避免创建临时对象。更少的对象创建意味着更少的垃圾收集,这对用户体验有直接的影响。&lt;/p&gt;
&lt;p&gt;#选择Static而不是Virtual&lt;/p&gt;
&lt;p&gt;如果你不需要访问一个对象的字段,可以使用static修饰你的方法。调用将快15%~20%。这是一种很好的做法,因为通过static你还可以知道调用的方法不能改变对象的状态。&lt;/p&gt;
&lt;p&gt;#使用static final修饰常量&lt;/p&gt;
&lt;p&gt;像这样在一个类的顶部声明常量：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static int intVal = 42;
static String strVal = &amp;quot;Hello, world!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译器生成一个类初始化方法,叫做&amp;lt; clinit &amp;gt;,当这个类第一次被使用时执行。这个函数将42存入intVal，还从class文件的常量表中提取了strVal的引用。当之后使用intVal或strVal的时候，他们会直接被查询到。&lt;/p&gt;
&lt;p&gt;我们可以用final关键字来优化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static final int intVal = 42;
static final String strVal = &amp;quot;Hello, world!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这时再也不需要上面的方法了，因为final声明的常量进入了静态dex文件的域初始化部分。调用intVal的代码会直接使用42，调用strVal的代码也会使用一个相对廉价的“string constant”指令，而不是查表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Notes：这个优化方法只对原始类型和String类型有效，而不是任意引用类型。不过，在必要时使用static final是个很好的习惯。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#避免内部的Getters/Setters&lt;/p&gt;
&lt;p&gt;像C++等native language，通常使用getters(i = getCount())而不是直接访问变量(i = mCount)。这是编写C++的一种优秀习惯，而且通常也被其他面向对象的语言所采用，例如C#与Java，因为编译器通常会做inline访问，而且你需要限制或者调试变量，你可以在任何时候在getter/setter里面添加代码。&lt;/p&gt;
&lt;p&gt;然而，在Android上，这不是一个好的写法。虚函数的调用比起直接访问变量要耗费更多。在面向对象编程中，将getter和setting暴露给公用接口是合理的，但在类内部应该仅仅使用域直接访问。&lt;/p&gt;
&lt;p&gt;在没有JIT(Just In Time Compiler)时，直接访问变量的速度是调用getter的3倍。有JIT时，直接访问变量的速度是通过getter访问的7倍。&lt;/p&gt;
&lt;p&gt;请注意，如果你使用&lt;a href=&quot;http://developer.android.com/tools/help/proguard.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ProGuard&lt;/a&gt;，你可以获得同样的效果，因为ProGuard可以为你内联访问.&lt;/p&gt;
&lt;p&gt;#使用for-each循环&lt;/p&gt;
&lt;p&gt;增强的For循环（也被称为 for-each 循环）可以被用在实现了 Iterable 接口的 collections 以及数组上。使用collection的时候，Iterator会被分配，用于for-each调用hasNext()和next()方法。使用ArrayList时，手写的计数式for循环会快3倍（不管有没有JIT），但是对于其他collection，增强的for-each循环写法会和迭代器写法的效率一样。&lt;/p&gt;
&lt;p&gt;请比较下面三种循环的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static class Foo {
    int mSplat;
}

Foo[] mArray = ...

public void zero() {
    int sum = 0;
    for (int i = 0; i &amp;lt; mArray.length; ++i) {
        sum += mArray[i].mSplat;
    }
}

public void one() {
    int sum = 0;
    Foo[] localArray = mArray;
    int len = localArray.length;

    for (int i = 0; i &amp;lt; len; ++i) {
        sum += localArray[i].mSplat;
    }
}

public void two() {
    int sum = 0;
    for (Foo a : mArray) {
        sum += a.mSplat;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;zero()是最慢的，因为JIT没有办法对它进行优化。&lt;/li&gt;
&lt;li&gt;one()稍微快些。&lt;/li&gt;
&lt;li&gt;two() 在没有做JIT时是最快的，可是如果经过JIT之后，与方法one()是差不多一样快的。它使用了增强的循环方法for-each。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以请尽量使用for-each的方法，但是对于ArrayList，请使用方法one()。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tips：你还可以参考 Josh Bloch 的 《Effective Java》这本书的第46条&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#使用package代替private以便私有内部类高效访问外部类成员&lt;/p&gt;
&lt;p&gt;参考下面一段代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class Foo {
    private class Inner {
        void stuff() {
            Foo.this.doStuff(Foo.this.mValue);
        }
    }

    private int mValue;

    public void run() {
        Inner in = new Inner();
        mValue = 27;
        in.stuff();
    }

    private void doStuff(int value) {
        System.out.println(&amp;quot;Value is &amp;quot; + value);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里重要的是，我们定义了一个私有的内部类（Foo$Inner），它直接访问了外部类中的私有方法以及私有成员对象。这是合法的，这段代码也会如同预期一样打印出”Value is 27”。&lt;/p&gt;
&lt;p&gt;问题是，VM(虚拟机)因为Foo和Foo$Inner是不同的类，会认为在Foo$Inner中直接访问Foo类的私有成员是不合法的。即使Java语言允许内部类访问外部类的私有成员。为了去除这种差异，编译器会产生一些仿造函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/*package*/ static int Foo.access$100(Foo foo) {
    return foo.mValue;
}
/*package*/ static void Foo.access$200(Foo foo, int value) {
    foo.doStuff(value);
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每当内部类需要访问外部类中的mValue成员或需要调用doStuff()函数时，它都会调用这些静态方法。这意味着，上面的代码可以归结为，通过accessor函数来访问成员变量。早些时候我们说过，通过accessor会比直接访问域要慢。所以，这是一个特定语言用法造成性能降低的例子。&lt;/p&gt;
&lt;p&gt;如果你正在性能热区（hotspot:高频率、重复执行的代码段）使用像这样的代码，你可以把内部类需要访问的域和方法声明为包级访问，而不是私有访问权限。不幸的是，这意味着在相同包中的其他类也可以直接访问这些域，所以在公开的API中你不能这样做。&lt;/p&gt;
&lt;p&gt;#避免使用浮点类型&lt;/p&gt;
&lt;p&gt;Android系统中float类型的数据存取速度是int类型的一半，尽量优先采用int类型。&lt;/p&gt;
&lt;p&gt;就速度而言，现代硬件上，float 和 double 的速度是一样的。空间而言，double 是两倍float的大小。在空间不是问题的情况下，你应该使用 double 。&lt;/p&gt;
&lt;p&gt;同样，对于整型，有些处理器实现了硬件几倍的乘法，但是没有除法。这时，整型的除法和取余是在软件内部实现的，这在你使用哈希表或大量计算操作时要考虑到。&lt;/p&gt;
&lt;p&gt;#了解并使用库函数&lt;/p&gt;
&lt;p&gt;除了那些常见的让你多使用自带库函数的理由以外，记得系统函数有时可以替代第三方库，并且还有汇编级别的优化，他们通常比带有JIT的Java编译出来的代码更高效。典型的例子是：Android API 中的 &lt;a href=&quot;http://developer.android.com/reference/java/lang/String.html#indexOf%28int%29&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;String.indexOf()&lt;/a&gt;，Dalvik出于内联性能考虑将其替换。同样 &lt;a href=&quot;http://developer.android.com/reference/java/lang/System.html#arraycopy%28java.lang.Object,%20int,%20java.lang.Object,%20int,%20int%29&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;System.arraycopy()&lt;/a&gt;函数也被替换，这样的性能在Nexus One测试，比手写的for循环并使用JIT还快9倍。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tips：参见 Josh Bloch 的 《Effective Java》这本书的第47条&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#小心使用底层方法&lt;/p&gt;
&lt;p&gt;结合&lt;a href=&quot;http://developer.android.com/tools/sdk/ndk/index.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Android NDK&lt;/a&gt;使用native代码开发，并不总是比Java直接开发的效率更好的。Java转native代码是有代价的，而且JIT不能在这种情况下做优化。如果你在native代码中分配资源（比如native堆上的内存，文件描述符等等），这会对收集这些资源造成巨大的困难。你同时也需要为各种架构重新编译代码（而不是依赖JIT）。你甚至对已同样架构的设备都需要编译多个版本：为G1的ARM架构编译的版本不能完全使用Nexus One上ARM架构的优势，反之亦然。&lt;/p&gt;
&lt;p&gt;Native 代码是在你已经有本地代码，想把它移植到Android平台时有优势，而不是为了优化已有的Android Java代码使用。&lt;/p&gt;
&lt;p&gt;如果你要使用JNI,请学习&lt;a href=&quot;http://developer.android.com/training/articles/perf-jni.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JNI Tips&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Tips：参见 Josh Bloch 的 《Effective Java》这本书的第54条&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;#性能谬见&lt;/p&gt;
&lt;p&gt;在没有JIT的设备上，使用一种确切的数据类型确实要比抽象的数据类型速度要更有效率（例如，调用HashMap map要比调用Map map效率更高）。有误传效率要高一倍，实际上只是6%左右。而且，在JIT之后，他们直接并没有大多差异。&lt;/p&gt;
&lt;p&gt;在没有JIT的设备上，读取缓存域比直接读取实际数据大概快20%。有JIT时，域读取和本地读取基本无差。所以优化并不值得除非你觉得能让你的代码更易读（这对 final, static, static final 域同样适用）。&lt;/p&gt;
&lt;p&gt;#关于测量&lt;/p&gt;
&lt;p&gt;在优化之前，你应该确定你遇到了性能问题。你应该确保你能够准确测量出现在的性能，否则你也不会知道优化是否真的有效。&lt;/p&gt;
&lt;p&gt;本章节中所有的技巧都需要Benchmark（基准测试）的支持。Benchmark可以在 &lt;a href=&quot;https://code.google.com/archive/p/dalvik/source#svn%2Ftrunk%2Fbenchmarks&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;code.google.com “dalvik” project&lt;/a&gt; 中找到。&lt;/p&gt;
&lt;p&gt;Benchmark是基于Java版本的 &lt;a href=&quot;https://github.com/google/caliper&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Caliper&lt;/a&gt; microbenchmarking框架开发的。Microbenchmarking很难做准确，所以Caliper帮你完成这部分工作，甚至还帮你测了你没想到需要测量的部分（因为，VM帮你管理了代码优化，你很难知道这部分优化有多大效果）。我们强烈推荐使用Caliper来做你的基准微测工作。&lt;/p&gt;
&lt;p&gt;我们也可以用&lt;a href=&quot;http://developer.android.com/tools/debugging/debugging-tracing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Traceview&lt;/a&gt; 来测量，但是测量的数据是没有经过JIT优化的，所以实际的效果应该是要比测量的数据稍微好些。&lt;/p&gt;
&lt;p&gt;关于如何测量与调试，还可以参考下面两篇文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://developer.android.com/tools/debugging/debugging-tracing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/tools/debugging/debugging-tracing.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://developer.android.com/tools/debugging/systrace.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://developer.android.com/tools/debugging/systrace.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是对官方文档中PerformanceTips（性能优化关键点）的翻译，欢迎拍砖。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="官方文档" scheme="http://yoursite.com/tags/%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化之被忽视的Memory Leaks</title>
    <link href="http://yoursite.com/2016/04/19/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84Memory%20Leaks/"/>
    <id>http://yoursite.com/2016/04/19/Android性能优化之被忽视的Memory Leaks/</id>
    <published>2016-04-19T10:16:00.000Z</published>
    <updated>2016-05-06T14:06:56.424Z</updated>
    
    <content type="html">&lt;p&gt;Android内存优化之内存泄漏的发现和处理，以及常见情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#起因&lt;/p&gt;
&lt;p&gt;写博客就像讲故事，得有起因，经过，结果，人物，地点和时间。今天就容我给大家讲一个故事。人物呢，肯定是我了。故事则发生在最近的这两天,地点在coder君上班的公司。那天无意中我发现了一个奇怪的现象，随着我点开我们App的页面，Memory Monitor中显示占用的内存越来越多（前面的页面已经finish掉了）。咦？什么鬼？&lt;/p&gt;
&lt;p&gt;#经过&lt;/p&gt;
&lt;p&gt;有了问题就解决嘛，俗话说的好，有bug要上，没有bug写个bug也要上。那到底是是什么问题会引起这个现象呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Android中内存相关的问题无非就是这么几点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory Leaks 内存泄漏&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memory Churn 内存抖动&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OutOfMemory  内存溢出&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阿西吧，仔细想想怎么这么像内存泄漏呢。那到底是不是呢？那我们就一点一点分析一下呗。&lt;/p&gt;
&lt;p&gt;##内存相关数据&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于内存我们可能想了解的数据大概有三点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;总内存&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private String getTotalMemory() {
    String str1 = &amp;quot;/proc/meminfo&amp;quot;;// 系统内存信息文件
    String str2;
    String[] arrayOfString;
    long initial_memory = 0;
    try {
        FileReader localFileReader = new FileReader(str1);
        BufferedReader localBufferedReader = new BufferedReader(
                localFileReader, 8192);
        str2 = localBufferedReader.readLine();// 读取meminfo第一行，系统总内存大小
        arrayOfString = str2.split(&amp;quot;\\s+&amp;quot;);
        for (String num : arrayOfString) {
            Log.i(str2, num + &amp;quot;\t&amp;quot;);
        }
        initial_memory = Integer.valueOf(arrayOfString[1]).intValue() * 1024;// 获得系统总内存，单位是KB，乘以1024转换为Byte
        localBufferedReader.close();
    } catch (IOException e) {
    }
    return Formatter.formatFileSize(getBaseContext(), initial_memory);// Byte转换为KB或者MB，内存大小规格化
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;系统当前可用内存&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private String getAvailMemory() {
    // 获取android当前可用内存大小
    ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
    ActivityManager.MemoryInfo mi = new ActivityManager.MemoryInfo();
    am.getMemoryInfo(mi);
    //mi.availMem; 当前系统的可用内存
    return Formatter.formatFileSize(getBaseContext(), mi.availMem);// 将获取的内存大小规格化
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;我们可以使用的内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;每一个Android设备都会有不同的RAM总大小与可用空间，因此不同设备为app提供了不同大小的heap限制。你可以通过调用getMemoryClass())来获取你的app的可用heap大小。如果你的app尝试申请更多的内存，会出现OutOfMemory的错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  在一些特殊的情景下，你可以通过在manifest的application标签下添加largeHeap=true的属性来声明一个更大的heap空间。如果你这样做，你可以通过getLargeMemoryClass())来获取到一个更大的heap size。&lt;/p&gt;
&lt;p&gt;  然而，能够获取更大heap的设计本意是为了一小部分会消耗大量RAM的应用(例如一个大图片的编辑应用)。不要轻易的因为你需要使用大量的内存而去请求一个大的heap size。只有当你清楚的知道哪里会使用大量的内存并且为什么这些内存必须被保留时才去使用large heap. 因此请尽量少使用large heap。使用额外的内存会影响系统整体的用户体验，并且会使得GC的每次运行时间更长。在任务切换时，系统的性能会变得大打折扣。&lt;/p&gt;
&lt;p&gt;  另外, large heap并不一定能够获取到更大的heap。在某些有严格限制的机器上，large heap的大小和通常的heap size是一样的。因此即使你申请了large heap，你还是应该通过执行getMemoryClass()来检查实际获取到的heap大小。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private String getAllocationMemory() {
    // 获取系统分配的内存大小
    ActivityManager am = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
    //开启了android:largeHeap=&amp;quot;true&amp;quot;,米4系统能分配的内存为512M，不开启为128M
    //return  am.getLargeMemoryClass()+&amp;quot;&amp;quot;;
    //return  am.getMemoryClass()+&amp;quot;&amp;quot;;
}        
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Java中的四种引用&lt;/p&gt;
&lt;p&gt;开始分析之前，有必要先了解下Java的内存分配与回收。&lt;/p&gt;
&lt;p&gt;Java的数据类型分为两类：基本数据类型、引用数据类型。&lt;/p&gt;
&lt;p&gt;基本数据类型的值存储在栈内存中，而引用数据类型需要开辟两块存储空间，一块在堆内存中，用于存储该类型的对象;另一块在栈内存中，用于存储堆内存中该对象的引用。&lt;/p&gt;
&lt;p&gt;其中引用类型变量分为四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;强引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  最常用的引用形式。把一个对象赋给一个引用类型变量，则为强引用。&lt;/p&gt;
&lt;p&gt;  只要一个引用是强引用，则垃圾回收器永远都无法回收这个对象的内存空间，除非JVM终止。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;软引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  当内存资源充足的时候，垃圾回收器不会回收软引用对应的对象的内存空间;但当内存资源紧张时，软引用所对应的对象就会被垃圾回收器回收。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//创建一个Student类型的软引用

SoftReference&amp;lt;Student&amp;gt; sr = new SoftReference&amp;lt;Student&amp;gt;(new Student());
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;弱引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  不管JVM内存资源是否紧张，只要垃圾回收器运行，弱引用所对应的对象就会被释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;虚引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  虚引用等于没有引用，无法通过虚引用访问其对应的对象。&lt;/p&gt;
&lt;p&gt;  软引用和弱引用在其对象被回收之后，这些引用会被添加到引用队列中去;而虚引用在其对象被回收之前，虚引用就被添加到引用队列中去了。因此虚引用可以在其对象被释放之前进行一些操作。&lt;/p&gt;
&lt;p&gt;  虚引用和引用队列绑定的方法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//创建引用队列  
ReferenceQueue&amp;lt;String&amp;gt; queue = new ReferenceQueue&amp;lt;String&amp;gt;();  
//创建虚引用，并绑定引用队列  
PhantomReference&amp;lt;String&amp;gt; str = new PhantomReference&amp;lt;String&amp;gt;(&amp;quot;啦啦啦&amp;quot;,queue);    
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##Garbage Collection Android中的垃圾回收&lt;/p&gt;
&lt;p&gt;Android系统会在适当的时机触发GC操作，一旦进行GC操作，就会&lt;strong&gt;将一些不再使用的对象进行回收&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行GC操作的时候，所有线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常来说，单个的GC并不会占用太多时间，但是大量不停的GC操作则会显著占用帧间隔时间(16ms)。如果在帧间隔时间里面做了过多的GC操作，那么自然其他类似计算，渲染等操作的可用时间就变得少了&lt;/p&gt;
&lt;p&gt;##Memory Leaks内存泄漏&lt;/p&gt;
&lt;p&gt;内存泄漏表示的是不再用到的对象因为被错误引用而无法进行回收。发生内存泄漏会导致Memory Generation中的剩余可用Heap Size越来越小，这样会导致频繁触发GC，更进一步引起性能问题。&lt;/p&gt;
&lt;p&gt;总结起来其实很简单：&lt;strong&gt;存在无效的引用!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存泄露可以引发很多的问题，常见的内存泄露导致问题如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;应用卡顿，响应速度慢（内存占用高时JVM虚拟机会频繁触发GC）;&lt;/strong&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;应用被从后台进程干为空进程；&lt;/strong&gt;  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;应用莫名的崩溃（也就是超过了HeepSize阈值引起OOM）；&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##内存泄漏分析工具&lt;/p&gt;
&lt;p&gt;看到这些问题，突然发现好像离真相越来越近了0.0。&lt;/p&gt;
&lt;p&gt;想要更加清楚地实时知晓当前应用程序的内存使用情况，我们需要通过一些工具来实现。比较好用的工具有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Memory Analyzer Tool&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LeakCanary&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面我们分开介绍。&lt;/p&gt;
&lt;p&gt;###Memory Analyzer Tool&lt;/p&gt;
&lt;p&gt;Memory Analysis Tools（&lt;a href=&quot;http://www.eclipse.org/mat/downloads.php&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;点我下载&lt;/a&gt;）是一个专门分析Java堆数据内存引用的工具，我们可以使用它方便的定位内存泄露原因，核心任务就是找到GC ROOT位置。接下来说下使用步骤。&lt;/p&gt;
&lt;p&gt;####抓取内存信息&lt;/p&gt;
&lt;p&gt;AndriodStudio中抓取内存信息还是很方便的，有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;使用Android Device Monitor&lt;/p&gt;
&lt;p&gt;  点击Android Studio工具栏上的Tool–&amp;gt;Android Device Monitor    &lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/7ndnk8N.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;  在Android Device Monitor界面中选在你要分析的应用程序的包名，点击Update Heap来更新统计信息，然后点击Cause GC即可查看当前堆的使用情况，点击Dump HPROF file，将该应用当前的内存信息保存成hprof文件，放在桌面即可，操作如下图&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/CuAzhDK.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;直接获取&lt;/p&gt;
&lt;p&gt;  Android Studio的最新版本可以直接获取hprof文件，但是注意&lt;strong&gt;在使用之前一定要手动点击 Initiate GC按钮手动触发GC&lt;/strong&gt;，这样抓到的内存使用情况就是不包括Unreachable对象的。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/mM8Dhr5.png&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;  稍等片刻，生成的文件会出现在captures中，然后选择文件，点击右键转换成标准的hprof文件，就可以在MAT中打开了。&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;http://i.imgur.com/gFGFREY.png&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####使用MAT工具查看分析&lt;/p&gt;
&lt;p&gt;这里我写了个简单的demo来测试，这个demo一共有两个页面，在跳转到第二个页面之后，新开一个现成去打印activity信息。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/**
 * 打印ActivityName
 */

public void printActivityName() {

    for (int i = 0; i &amp;lt; 100; i++) {

        new Thread(new Runnable() {

            @Override

            public void run() {

                while (true)

                    try {

                        Thread.sleep(1000 * 30);

                        Log.e(ActivityHelper.class.getSimpleName(), ((Activity) mContext).getClass().getSimpleName());

                    } catch (InterruptedException e) {

                        e.printStackTrace();

                    }

            }

        }).start();

    }

}    
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;多次进入SecondActivity之后会发现内存一直在增长，并没有降低。&lt;/p&gt;
&lt;p&gt;而且log里会不停的输出log，打印当前activity的name。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/ETupC9m.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/3t9RMon.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在MAT中打开抓取到的文件后如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/Gv0jNbl.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;MAT中提供了非常多的功能，这里我们只要学习几个最常用的就可以了。上图最中央的那个饼状图展示了最大的几个对象所占内存的比例，这张图中提供的内容并不多，我们可以忽略它。红色框中有两个非常有用的工具是我们常用的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Histogram可以列出内存中每个对象的名字、数量以及大小。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dominator Tree会将所有内存中的对象按大小进行排序，并且我们可以分析对象之间的引用结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先来看Histogram&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/lBC3TnL.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们应该如何去分析内存泄漏呢?即分析大内存的对象。但是假如我们有目标对象的话，左上角值支持正则表达式的，我们输入SecondActivity。这里我们看到，我们有5个SecondActivity的实例，因为我们引用SecondActivity的现成没有销毁，导致会有很多实例。&lt;/p&gt;
&lt;p&gt;接下来对着SecondActivity右键 -&amp;gt; List objects -&amp;gt; with incoming references查看具体SecondActivity实例，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/eeWrRF0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果想要查看内存泄漏的具体原因，可以对着任意一个MainActivity的实例右键 -&amp;gt; Path to GC Roots -&amp;gt; exclude weak references，结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/PmxCiLs.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到红色框中，因为我们的线程持有SecondActivity的实例，所有导致内存泄漏。&lt;/p&gt;
&lt;p&gt;此外，我们可以选择以我们项目的包结构的形式来查看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/rKwJGtr.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;接下来我们看下Dominator Tree。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/e4mc0Gc.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于Dominator Tree我们需要注意三点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先Retained Heap表示这个对象以及它所持有的其它引用（包括直接和间接）所占的总内存，因此从上图中看，前两行的Retained Heap是最大的，我们分析内存泄漏时，内存最大的对象也是最应该去怀疑的。&lt;/li&gt;
&lt;li&gt;带有黄点的对象就表示是可以被GC Roots访问到的，根据上面的讲解，可以被GC Root访问到的对象都是无法被回收的。&lt;/li&gt;
&lt;li&gt;并不是所有带黄点的对象都是泄漏的对象，有些对象系统需要一直使用，本来就不应该被回收。我们可以注意到，有些带黄点的对象最右边会写一个System Class，说明这是一个由系统管理的对象，并不是由我们自己创建并导致内存泄漏的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在我们可以对着我们想查看的内容点击右键 -&amp;gt; Path to GC Roots -&amp;gt; exclude weak references，为什么选择exclude weak references呢？因为弱引用是不会阻止对象被垃圾回收器回收的，所以我们这里直接把它排除掉，然后一步一步分析。&lt;/p&gt;
&lt;p&gt;###LeakCanary&lt;/p&gt;
&lt;p&gt;leakcanary是一个开源项目，一个内存泄露自动检测工具，是著名的GitHub开源组织Square贡献的，它的主要优势就在于自动化过早的发觉内存泄露、配置简单、抓取贴心，缺点在于还存在一些bug，不过正常使用百分之九十情况是OK的，其核心原理与MAT工具类似。&lt;/p&gt;
&lt;p&gt;因为配置十分简单，这里就不多说了，&lt;a href=&quot;https://github.com/square/leakcanary&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;官方文档。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们看下分析结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/BE8T7JP.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;简单直白！&lt;/p&gt;
&lt;p&gt;##常见内存泄漏情况&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;构造Adapter时，没有使用缓存的 convertView &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Bitmap对象不在使用时调用recycle()释放内存 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Context使用不当造成内存泄露：不要对一个Activity Context保持长生命周期的引用。尽量在一切可以使用应用ApplicationContext代替Context的地方进行替换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;非静态内部类的静态实例容易造成内存泄漏：即一个类中如果你不能够控制它其中内部类的生命周期（譬如Activity中的一些特殊Handler等），则尽量使用静态类和弱引用来处理（譬如ViewRoot的实现）。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;警惕线程未终止造成的内存泄露；譬如在Activity中关联了一个生命周期超过Activity的Thread，在退出Activity时切记结束线程。一个典型的例子就是HandlerThread的run方法是一个死循环，它不会自己结束，线程的生命周期超过了Activity生命周期，我们必须手动在Activity的销毁方法中中调运thread.getLooper().quit();才不会泄露。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;对象的注册与反注册没有成对出现造成的内存泄露；譬如注册广播接收器、注册观察者（典型的譬如数据库的监听）等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建与关闭没有成对出现造成的泄露；譬如Cursor资源必须手动关闭，WebView必须手动销毁，流等对象必须手动关闭等。  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不要在执行频率很高的方法或者循环中创建对象（比如onmeasure），可以使用HashTable等创建一组对象容器从容器中取那些对象，而不用每次new与释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免代码设计模式的错误造成内存泄露；譬如循环引用，A持有B，B持有C，C持有A，这样的设计谁都得不到释放。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#结果&lt;/p&gt;
&lt;p&gt;真相只有一个，那就是确实是由于内存泄漏才出现我遇到的情况。程序员嘛，谁还不踩个坑，跳出来，拍拍身上的灰尘，总结一下，过两天又是一条帮帮的coder。&lt;a href=&quot;http://download.csdn.net/detail/sdkfjksf/9496090&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Android内存优化之内存泄漏的发现和处理，以及常见情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="性能优化" scheme="http://yoursite.com/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="内存优化" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    
      <category term="MAT" scheme="http://yoursite.com/tags/MAT/"/>
    
      <category term="leakcanary" scheme="http://yoursite.com/tags/leakcanary/"/>
    
      <category term="内存泄漏" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Androd自定义控件（五）打造自己的Camera</title>
    <link href="http://yoursite.com/2016/04/12/Androd%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6%EF%BC%88%E4%BA%94%EF%BC%89%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84Camera/"/>
    <id>http://yoursite.com/2016/04/12/Androd自定义控件（五）打造自己的Camera/</id>
    <published>2016-04-12T13:30:00.000Z</published>
    <updated>2016-05-06T14:31:36.269Z</updated>
    
    <content type="html">&lt;p&gt;使用surfaceview自定义相机，同时把自己踩过的坑分享给大家，希望大家有所收获。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;#写在前面的话&lt;br&gt;前一阵子负责一个自定义相机进行拍照并在另一个页面进行人脸识别的模块，相机部分需求并不怎么复杂，可以切换前后摄像头，可以拍照并把照片返回上一个页面。由于没有怎么接触过自定义相机的部分，而网上的一些资料又不全，踩了不少坑。故在这里总结一下，希望对大家有所帮助，同时把自定义控件系列的最后一个坑填上（surfaceview）。效果图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20160412212407832&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;#Android中开发相机的两种方式&lt;/p&gt;
&lt;p&gt;Android系统提供了两种使用手机相机资源实现拍摄功能的方法，&lt;strong&gt;一种是直接通过Intent调用系统相机组件&lt;/strong&gt;，这种方法快速方便，适用于直接获得照片的场景，如上传相册，微博、朋友圈发照片等。&lt;strong&gt;另一种是使用相机API来定制自定义相机&lt;/strong&gt;，这种方法适用于需要定制相机界面或者开发特殊相机功能的场景，如需要对照片做裁剪、滤镜处理，添加贴纸，表情，地点标签等。&lt;/p&gt;
&lt;p&gt;##调用系统自带相机&lt;br&gt;关于系统自带相机的调用非常简单，这里我就不过多叙述了，具体可以参考谷歌的&lt;a href=&quot;http://developer.android.com/training/camera/photobasics.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Training&lt;/a&gt;。我只说容易被大家忽视的几个点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果我们的应用使用相机，但相机并不是应用的正常运行所必不可少的组件，可以将权限声明中的android:required设置为”false”。这样的话，Google Play 也会允许没有相机的设备下载该应用。当然我们有必要在使用相机之前通过调用hasSystemFeature(PackageManager.FEATURE_CAMERA)方法来检查设备上是否有相机。如果没有，我们应该禁用和相机相关的功能！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在调用startActivityForResult()方法之前，先调用resolveActivity()，这个方法会返回能处理该Intent的第一个Activity（译注：即检查有没有能处理这个Intent的Activity）。执行这个检查非常重要，因为如果在调用startActivityForResult()时，没有应用能处理你的Intent，应用将会崩溃。所以只要返回结果不为null，使用该Intent就是安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;##使用Android框架所提供的API来直接控制相机硬件&lt;/p&gt;
&lt;p&gt;使用API来控制相机我们需要用到关键类和接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Camera对象来控制相机&lt;/li&gt;
&lt;li&gt;使用SurfaceView来展现照相机采集的图像&lt;/li&gt;
&lt;li&gt;通过surfaceholder来控制surfac的尺寸和格式，修改surface的像素，监视surface的变化等等&lt;/li&gt;
&lt;li&gt;通过SurfaceHolder.Callback 接口，监听surface状态变化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来我们分为以下三部分来介绍：关键类以及接口的作用和方法，Camera控制拍照步骤，自定义相机容易踩到的坑以及解决办法。&lt;/p&gt;
&lt;p&gt;###&lt;strong&gt;API说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Camera ：最主要的类，用于管理和操作camera资源。它提供了完整的相机底层接口，支持相机资源切换，设置预览/拍摄尺寸，设定光圈、曝光、聚焦等相关参数，获取预览/拍摄帧数据等功能，主要方法有以下这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;open()：获取camera实例。&lt;/li&gt;
&lt;li&gt;setPreviewDisplay(SurfaceHolder)：绑定绘制预览图像的surface。surface是指向屏幕窗口原始图像缓冲区（raw buffer）的一个句柄，通过它可以获得这块屏幕上对应的canvas，进而完成在屏幕上绘制View的工作。通过surfaceHolder可以将Camera和surface连接起来，当camera和surface连接后，camera获得的预览帧数据就可以通过surface显示在屏幕上了。&lt;/li&gt;
&lt;li&gt;setPrameters设置相机参数，包括前后摄像头，闪光灯模式、聚焦模式、预览和拍照尺寸等。&lt;/li&gt;
&lt;li&gt;startPreview():开始预览，将camera底层硬件传来的预览帧数据显示在绑定的surface上。&lt;/li&gt;
&lt;li&gt;stopPreview():停止预览，关闭camra底层的帧数据传递以及surface上的绘制。&lt;/li&gt;
&lt;li&gt;release():释放Camera实例&lt;/li&gt;
&lt;li&gt;takePicture(Camera.ShutterCallback shutter, Camera.PictureCallback raw, Camera.PictureCallback jpeg):这个是实现相机拍照的主要方法，包含了三个回调参数。shutter是快门按下时的回调，raw是获取拍照原始数据的回调，jpeg是获取经过压缩成jpg格式的图像数据的回调。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SurfaceView ：用于绘制相机预览图像的类，提供给用户实时的预览图像。普通的view以及派生类都是共享同一个surface的，所有的绘制都必须在UI线程中进行。而surfaceview是一种比较特殊的view，它并不与其他普通view共享surface，而是在内部持有了一个独立的surface,surfaceview负责管理这个surface的格式、尺寸以及显示位置。由于UI线程还要同时处理其他交互逻辑，因此对view的更新速度和帧率无法保证，而surfaceview由于持有一个独立的surface，因而可以在独立的线程中进行绘制，因此可以提供更高的帧率。自定义相机的预览图像由于对更新速度和帧率要求比较高，所以比较适合用surfaceview来显示。&lt;/p&gt;
&lt;p&gt;SurfaceHolder ：surfaceholder是控制surface的一个抽象接口，它能够控制surface的尺寸和格式，修改surface的像素，监视surface的变化等等，surfaceholder的典型应用就是用于surfaceview中。surfaceview通过getHolder()方法获得surfaceholder 实例，通过后者管理监听surface 的状态。&lt;/p&gt;
&lt;p&gt;SurfaceHolder.Callback 接口 ：负责监听surface状态变化的接口，有三个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;surfaceCreated(SurfaceHolder holder)：在surface创建后立即被调用。在开发自定义相机时，可以通过重载这个函数调用camera.open()、camera.setPreviewDisplay()，来实现获取相机资源、连接camera和surface等操作。&lt;/li&gt;
&lt;li&gt;surfaceChanged(SurfaceHolder holder, int format, int width, int height):在surface发生format或size变化时调用。在开发自定义相机时，可以通过重载这个函数调用camera.startPreview来开启相机预览，使得camera预览帧数据可以传递给surface，从而实时显示相机预览图像。&lt;/li&gt;
&lt;li&gt;surfaceDestroyed(SurfaceHolder holder)：在surface销毁之前被调用。在开发自定义相机时，可以通过重载这个函数调用camera.stopPreview()，camera.release()来实现停止相机预览及释放相机资源等操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;###&lt;strong&gt;Camera控制拍照的过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用Camera的open()方法打开相机。&lt;/li&gt;
&lt;li&gt;调用Camera的getParameters（）获取拍照参数，该方法返回一个Cmera.Parameters对象。&lt;/li&gt;
&lt;li&gt;调用Camera.Parameters对象对照相的参数进行设置。&lt;/li&gt;
&lt;li&gt;调用Camera的setParameters（），并将Camera.Parameters对象作为参数传入，这样就可以对拍照进行参数控制，Android2.3.3以后不用设置。&lt;/li&gt;
&lt;li&gt;调用Camerade的startPreview()的方法开始预览取景，在之前需要调用Camera的setPreviewDisplay(SurfaceHolder holder)设置使用哪个SurfaceView来显示取得的图片。&lt;/li&gt;
&lt;li&gt;调用Camera的takePicture()方法进行拍照。&lt;/li&gt;
&lt;li&gt;程序结束时，要调用Camera的stopPreview()方法停止预览，并且通过Camera.release()来释放资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体实现代码戳后面链接&lt;/p&gt;
&lt;p&gt;###&lt;strong&gt;踩坑与填坑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;####&lt;strong&gt;预览方向&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先看下官方文档的说明&lt;/p&gt;
&lt;p&gt;Most camera applications lock the display into landscape mode because that is the natural orientation of the camera sensor. This setting does not prevent you from taking portrait-mode photos, because the orientation of the device is recorded in the EXIF header. The setCameraDisplayOrientation() method lets you change how the preview is displayed without affecting how the image is recorded. However, in Android prior to API level 14, you must stop your preview before changing the orientation and then restart it.&lt;/p&gt;
&lt;p&gt;大多数相机程序会锁定预览为横屏状态，因为该方向是相机传感器的自然方向。当然这一设定并不会阻止我们去拍竖屏的照片，因为设备的方向信息会被记录在EXIF头中。setCameraDisplayOrientation()方法可以让你在不影响照片拍摄过程的情况下，改变预览的方向。然而，对于Android API Level 14及以下版本的系统，在改变方向之前，我们必须先停止预览，然后再去重启它。&lt;/p&gt;
&lt;p&gt;####&lt;strong&gt;SurfaceView预览图像拉伸变形，拍摄照片尺寸不对&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;说明这个问题之前，同样先说一下几个跟相机有关的尺寸。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;SurfaceView尺寸 ：即自定义相机应用中用于显示相机预览图像的View的尺寸，当它铺满全屏时就是屏幕的大小。这里surfaceview显示的预览图像暂且称作手机预览图像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Previewsize ：相机硬件提供的预览帧数据尺寸。预览帧数据传递给SurfaceView，实现预览图像的显示。这里预览帧数据对应的预览图像暂且称作相机预览图像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Picturesize ：相机硬件提供的拍摄帧数据尺寸。拍摄帧数据可以生成位图文件，最终保存成.jpg或者.png等格式的图片。这里拍摄帧数据对应的图像称作相机拍摄图像。图4说明了以上几种图像及照片之间的关系。手机预览图像是直接提供给用户看的图像，它由相机预览图像生成，拍摄照片的数据则来自于相机拍摄图像。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原因是没有正确设置比例 parameter.setPictureSize(width,height)，这个比例不是你决定的，要先通过camera.getParameters().getSupportedPictureSizes()获得手机支持的尺寸。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     * 设置照片格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private void setParameter() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Camera.Parameters parameters = camera.getParameters(); // 获取各项参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        parameters.setPictureFormat(PixelFormat.JPEG); // 设置图片格式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        parameters.setJpegQuality(100); // 设置照片质量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //获得相机支持的照片尺寸,选择合适的尺寸&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Camera.Size&amp;gt; sizes = parameters.getSupportedPictureSizes();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int maxSize = Math.max(display.getWidth(), display.getHeight());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int length = sizes.size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (maxSize &amp;gt; 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for (int i = 0; i &amp;lt; length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (maxSize &amp;lt;= Math.max(sizes.get(i).width, sizes.get(i).height)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    parameters.setPictureSize(sizes.get(i).width, sizes.get(i).height);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Camera.Size&amp;gt; ShowSizes = parameters.getSupportedPreviewSizes();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int showLength = ShowSizes.size();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (maxSize &amp;gt; 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            for (int i = 0; i &amp;lt; showLength; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                if (maxSize &amp;lt;= Math.max(ShowSizes.get(i).width, ShowSizes.get(i).height)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    parameters.setPreviewSize(ShowSizes.get(i).width, ShowSizes.get(i).height);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        camera.setParameters(parameters);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;####&lt;strong&gt;前置摄像头的镜像效果&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Android 相机硬件有个特殊设定，就是对于前置摄像头，在展示预览视图时采用类似镜面的效果，显示的是摄像头成像的镜像。而拍摄出的照片则仍采用摄像头成像。看到这里，大家可能会有些怀疑，不妨现在就试试自己 Android 手机上的前置摄像头，对比下预览图像和拍摄出照片的区别。这是由于底层相机在传递前置摄像头预览数据时做了水平翻转变换，即将x方向镜像翻转180度。这个变化对之前竖屏预览的方向也会造成影响，本来对于后置摄像头旋转90度即可使预览视图正确，而对前置摄像头，如果也旋转90度的话，看到的预览图像则是上下颠倒的（因为x方向翻转了180度），因此必须再旋转180度，才能显示正确。&lt;br&gt;解决方案，在保存图片的时候根据选择的摄像头做对应的翻转。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//将照片改为竖直方向&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    Matrix matrix = new Matrix();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    switch (cameraPosition) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        case 0://前&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            matrix.preRotate(270);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                        case 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            matrix.preRotate(90);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                            break;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), matrix, true);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;同时在开发的过程中发现了一个有趣的东西，我们用前置摄像头拍出来的照片其实是左右翻转的。但我用小米自带的相机测试发现，当摄像头中有人脸出现的时候，相机会做左右翻转的操作，以给用户更好的体验。    &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://download.csdn.net/detail/sdkfjksf/9489134&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;源码戳这里。&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;使用surfaceview自定义相机，同时把自己踩过的坑分享给大家，希望大家有所收获。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
    
    </summary>
    
      <category term="自定义控件" scheme="http://yoursite.com/categories/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
    
      <category term="自定义控件" scheme="http://yoursite.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
    
      <category term="Camera" scheme="http://yoursite.com/tags/Camera/"/>
    
      <category term="surfaceview" scheme="http://yoursite.com/tags/surfaceview/"/>
    
      <category term="相机" scheme="http://yoursite.com/tags/%E7%9B%B8%E6%9C%BA/"/>
    
  </entry>
  
</feed>
